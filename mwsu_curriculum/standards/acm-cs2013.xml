<?xml version="1.0" encoding="UTF-8"?>
<curriculumStandard
  xmlns="https://csmp.missouriwestern.edu"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://csmp.missouriwestern.edu/xml/curriculum/standard.xsd">

 <name>Computer Science Curricula</name>
 <body>acm/ieee</body>
 <version>2013</version> 
 <documentUrl>https://www.acm.org/binaries/content/assets/education/cs2013_web_final.pdf</documentUrl>

  <knowledgeArea id='AL' name='Algorithms and Complexity'>
    <knowledgeArea id='BA' name='Basic Analysis'>
      <topic importance='tier1'> Differences among best, expected, and worst case behaviors of an algorithm
      </topic>
      <topic importance='tier1'> Asymptotic analysis of upper and expected complexity bounds
      </topic>
      <topic importance='tier1'> Big O notation: formal definition
      </topic>
      <topic importance='tier1'> Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential
      </topic>
      <topic importance='tier1'> Empirical measurements of performance
      </topic>
      <topic importance='tier1'> Time and space  trade-offs  in algorithms
      </topic>
      <topic importance='tier2'> Big O notation: use
      </topic>
      <topic importance='tier2'> Little o, big omega and big theta notation
      </topic>
      <topic importance='tier2'> Recurrence relations
      </topic>
      <topic importance='tier2'> Analysis of iterative and recursive algorithms
      </topic>
      <topic importance='tier2'> Some version of a Master Theorem
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain what is meant by “best”, “expected”, and “worst” case behavior of an algorithm. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>In the context of specific algorithms, identify the characteristics of data and/or other conditions or assumptions that lead to different behaviors. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Determine informally the time and space complexity of simple algorithms. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>State the formal definition of big O. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>List and contrast standard complexity classes. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Perform empirical studies to validate hypotheses about runtime stemming from mathematical analysis. Run algorithms on input of various sizes and compare performance. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Give examples that illustrate  time-space   trade-offs  of algorithms. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use big O notation formally to give asymptotic upper bounds on time and space complexity of algorithms. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use big O notation formally to give expected case bounds on time complexity of algorithms. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the use of big omega, big theta, and little o notation to describe the amount of work done by an algorithm. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use recurrence relations to determine the time complexity of recursively defined algorithms. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Solve elementary recurrence relations, e.g., using some form of a Master Theorem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AS' name='Algorithmic Strategies'>
      <topic importance='tier1'> Brute-force  algorithms
      </topic>
      <topic importance='tier1'> Greedy algorithms
      </topic>
      <topic importance='tier1'> Divide-and-conquer   (cross-reference  SDF/Algorithms and  Design/Problem-solving  strategies)
      </topic>
      <topic importance='tier1'> Recursive backtracking
      </topic>
      <topic importance='tier1'> Dynamic Programming
      </topic>
      <topic importance='tier2'> Branch-and-bound
      </topic>
      <topic importance='tier2'> Heuristics
      </topic>
      <topic importance='tier2'> Reduction:  transform-and-conquer
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>For each of the strategies  (brute-force,  greedy,  divide-and-conquer,  recursive backtracking, and dynamic programming), identify a practical example to which it would apply. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Use a greedy approach to solve an appropriate problem and determine if the greedy rule chosen leads to an optimal solution. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use a  divide-and-conquer  algorithm to solve an appropriate problem. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use recursive backtracking to solve a problem such as navigating a maze. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use dynamic programming to solve an appropriate problem. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Determine an appropriate algorithmic approach to a problem. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe various heuristic  problem-solving  methods. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use a heuristic approach to solve an appropriate problem. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Describe the  trade-offs  between brute force and heuristic strategies. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how a  branch-and-bound  approach may be used to improve the performance of a heuristic method. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FDSAA' name='Fundamental Data Structures and Algorithms'>
      <topic importance='tier1'> Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max, and mode in a list, approximating the square root of a number, or finding the greatest common divisor
      </topic>
      <topic importance='tier1'> Sequential and binary search algorithms
      </topic>
      <topic importance='tier1'> Worst case quadratic sorting algorithms (selection, insertion)
      </topic>
      <topic importance='tier1'> Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort)
      </topic>
      <topic importance='tier1'> Hash tables, including strategies for avoiding and resolving collisions
      </topic>
      <topic importance='tier1'> Binary search trees</topic>
      <topic importance='tier1'> Common operations on binary search trees such as select min, max, insert, delete, iterate over tree</topic>
      <topic importance='tier1'> Graphs and graph algorithms</topic>
      <topic importance='tier1'> Representations of graphs (e.g., adjacency list, adjacency matrix)</topic>
      <topic importance='tier1'> Depth- and  breadth-first  traversals</topic>
      <topic importance='tier2'> Heaps
      </topic>
      <topic importance='tier2'> Graphs and graph algorithms</topic>
      <topic importance='tier2'>Shortest-path  algorithms (Dijkstra’s and Floyd’s algorithms)</topic>
      <topic importance='tier2'>inimum spanning tree (Prim’s and Kruskal’s algorithms)
      </topic>
      <topic importance='tier2'> Pattern matching and string/text algorithms (e.g., substring matching, regular expression matching, longest common subsequence algorithms)
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Implement basic numerical algorithms. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Implement simple search algorithms and explain the differences in their time complexities. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Be able to implement common quadratic and O(N log N) sorting algorithms. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the implementation of hash tables, including collision avoidance and resolution. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the runtime and memory efficiency of principal algorithms for sorting, searching, and hashing. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss factors other than computational efficiency that influence the choice of algorithms, such as programming time, maintainability, and the use of  application-specific  patterns in the input data. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain how tree balance affects the efficiency of various binary search tree operations. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Solve problems using fundamental graph algorithms, including  depth-first  and  breadth-first  search. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Demonstrate the ability to evaluate algorithms, to select from a range of possible options, to provide justification for that selection, and to implement the algorithm in a particular context. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the heap property and the use of heaps as an implementation of priority queues. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Solve problems using graph algorithms, including  single-source  and  all-pairs  shortest paths, and at least one minimum spanning tree algorithm. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Trace and/or implement a  string-matching  algorithm. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BACAC' name='Basic Automata Computability and Complexity'>
      <topic importance='tier1'> Finite-state  machines
      </topic>
      <topic importance='tier1'> Regular expressions
      </topic>
      <topic importance='tier1'> The halting problem
      </topic>
      <topic importance='tier2'> Context-free  grammars  (cross-reference  PL/Syntax Analysis)
      </topic>
      <topic importance='tier2'> Introduction to the P and NP classes and the P vs. NP problem
      </topic>
      <topic importance='tier2'> Introduction to the  NP-complete  class and exemplary  NP-complete  problems (e.g., SAT, Knapsack)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the concept of finite state machines. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Design a deterministic finite state machine to accept a specified language. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Generate a regular expression to represent a specified language. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain why the halting problem has no algorithmic solution. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Design a  context-free  grammar to represent a specified language. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Define the classes P and NP. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the significance of  NP-completeness.  </outcome>
    </knowledgeArea>
    <knowledgeArea id='ACC' name='Advanced Computational Complexity'>
      <topic importance='elective'> Review of the classes P and NP; introduce  P-space  and EXP
      </topic>
      <topic importance='elective'> Polynomial hierarchy
      </topic>
      <topic importance='elective'> NP-completeness  (Cook’s theorem)
      </topic>
      <topic importance='elective'> Classic  NP-complete  problems
      </topic>
      <topic importance='elective'> Reduction Techniques
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Define the classes P and NP. (Also appears in AL/Basic Automata, Computability, and Complexity). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Define the  P-space  class and its relation to the EXP class. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the significance of  NP-completeness.  (Also appears in AL/Basic Automata, Computability, and Complexity). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Provide examples of classic  NP-complete  problems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Prove that a problem is  NP-complete  by reducing a classic known  NP-complete  problem to it. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AATAC' name='Advanced Automata Theory and Computability'>
      <topic importance='elective'> Sets and languages</topic>
        <topic importance='elective'> Regular languages</topic>
        <topic importance='elective'> Review of deterministic finite automata (DFAs)</topic>
        <topic importance='elective'> Nondeterministic finite automata (NFAs)</topic>
        <topic importance='elective'> Equivalence of DFAs and NFAs</topic>
        <topic importance='elective'> Review of regular expressions; their equivalence to finite automata</topic>
        <topic importance='elective'> Closure properties</topic>
        <topic importance='elective'> Proving languages  non-regular,  via the pumping lemma or alternative means</topic>
      <topic importance='elective'> Context-free  languages</topic>
      <topic importance='elective'> Push-down  automata (PDAs)</topic>
      <topic importance='elective'>Relationship of PDAs and  context-free  grammars</topic>
      <topic importance='elective'>roperties of  context-free  languages
      </topic>
      <topic importance='elective'> Turing machines, or an equivalent formal model of universal computation
      </topic>
      <topic importance='elective'> Nondeterministic Turing machines
      </topic>
      <topic importance='elective'> Chomsky hierarchy
      </topic>
      <topic importance='elective'> The  Church-Turing  thesis
      </topic>
      <topic importance='elective'> Computability
      </topic>
      <topic importance='elective'> Rice’s Theorem
      </topic>
      <topic importance='elective'> Examples of uncomputable functions
      </topic>
      <topic importance='elective'> Implications of uncomputability
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Determine a language’s place in the Chomsky hierarchy (regular,  context-free,  recursively enumerable). </outcome>
      <outcome importance='elective' mastery_level='usage'>Convert among equivalently powerful notations for a language, including among DFAs, NFAs, and regular expressions, and between PDAs and CFGs. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the  Church-Turing  thesis and its significance. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain Rice’s Theorem and its significance. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Provide examples of uncomputable functions. </outcome>
      <outcome importance='elective' mastery_level='usage'>Prove that a problem is uncomputable by reducing a classic known uncomputable problem to it. </outcome>
    </knowledgeArea>
    <knowledgeArea id='ADSAAA' name='Advanced Data Structures Algorithms and Analysis'>
      <topic importance='elective'> Balanced trees (e.g., AVL trees,  red-black  trees, splay trees, treaps)
      </topic>
      <topic importance='elective'> Graphs (e.g., topological sort, finding strongly connected components, matching)
      </topic>
      <topic importance='elective'> Advanced data structures (e.g.,  B-trees,  Fibonacci heaps)
      </topic>
      <topic importance='elective'> String-based  data structures and algorithms (e.g., suffix arrays, suffix trees, tries)
      </topic>
      <topic importance='elective'> Network flows (e.g., max flow  [Ford-Fulkerson  algorithm], max flow – min cut, maximum bipartite matching)
      </topic>
      <topic importance='elective'> Linear Programming (e.g., duality, simplex method, interior point algorithms)
      </topic>
      <topic importance='elective'> Number-theoretic  algorithms (e.g., modular arithmetic, primality testing, integer factorization)
      </topic>
      <topic importance='elective'> Geometric algorithms (e.g., points, line segments, polygons. [properties, intersections], finding convex hull, spatial decomposition, collision detection, geometric search/proximity)
      </topic>
      <topic importance='elective'> Randomized algorithms
      </topic>
      <topic importance='elective'> Stochastic algorithms
      </topic>
      <topic importance='elective'> Approximation algorithms
      </topic>
      <topic importance='elective'> Amortized analysis
      </topic>
      <topic importance='elective'> Probabilistic analysis
      </topic>
      <topic importance='elective'> Online algorithms and competitive analysis
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Understand the mapping of  real-world  problems to algorithmic solutions (e.g., as graph problems, linear programs, etc.). </outcome>
      <outcome importance='elective' mastery_level='assessment'>Select and apply advanced algorithmic techniques (e.g., randomization, approximation) to solve real problems. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Select and apply advanced analysis techniques (e.g., amortized, probabilistic, etc.) to algorithms. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='AR' name='Architecture and Organization'>
    <knowledgeArea id='DLADS' name='Digital Logic and Digital Systems'>
      <topic importance='tier2'> Overview and history of computer architecture
      </topic>
      <topic importance='tier2'> Combinational vs. sequential logic/Field programmable gate arrays as a fundamental combinational + sequential logic building block
      </topic>
      <topic importance='tier2'> Multiple representations/layers of interpretation (hardware is just another layer)
      </topic>
      <topic importance='tier2'> Computer-aided  design tools that process hardware and architectural representations
      </topic>
      <topic importance='tier2'> Register transfer notation/Hardware Description Language (Verilog/VHDL)
      </topic>
      <topic importance='tier2'> Physical constraints (gate delays,  fan-in,   fan-out,  energy/power)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the progression of computer technology components from vacuum tubes to VLSI, from mainframe computer architectures to the organization of  warehouse-scale  computers. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Comprehend the trend of modern computer architectures towards  multi-core  and that parallelism is inherent in all hardware systems. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the implications of the “power wall” in terms of further processor performance improvements and the drive towards harnessing parallelism. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Articulate that there are many equivalent representations of computer functionality, including logical expressions and gates, and be able to use mathematical expressions to describe the functions of simple combinational and sequential circuits. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Design the basic building blocks of a computer:  arithmetic-logic  unit  (gate-level),  registers  (gate-level),  central processing unit (register  transfer-level),  memory (register  transfer-level).  </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use CAD tools for capture, synthesis, and simulation to evaluate simple building blocks (e.g., arithmetic- logic unit, registers, movement between registers) of a simple computer design. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Evaluate the functional and timing diagram behavior of a simple processor implemented at the logic circuit level. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MLROD' name='Machine Level Representation of Data'>
      <topic importance='tier2'> Bits, bytes, and words
      </topic>
      <topic importance='tier2'> Numeric data representation and number bases
      </topic>
      <topic importance='tier2'> Fixed- and  floating-point  systems
      </topic>
      <topic importance='tier2'> Signed and  twos-complement  representations
      </topic>
      <topic importance='tier2'> Representation of  non-numeric  data (character codes, graphical data)
      </topic>
      <topic importance='tier2'> Representation of records and arrays
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain why everything is data, including instructions, in computers. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the reasons for using alternative formats to represent numerical data. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how negative integers are stored in  sign-magnitude  and  twos-complement  representations. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how  fixed-length  number representations affect accuracy and precision. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the internal representation of  non-numeric  data, such as characters, strings, records, and arrays. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Convert numerical data from one format to another. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write simple programs at the assembly/machine level for string processing and manipulation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='ALMO' name='Assembly Level Machine Organization'>
      <topic importance='tier2'> Basic organization of the von Neumann machine
      </topic>
      <topic importance='tier2'> Control unit; instruction fetch, decode, and execution
      </topic>
      <topic importance='tier2'> Instruction sets and types (data manipulation, control, I/O)
      </topic>
      <topic importance='tier2'> Assembly/machine language programming
      </topic>
      <topic importance='tier2'> Instruction formats
      </topic>
      <topic importance='tier2'> Addressing modes
      </topic>
      <topic importance='tier2'> Subroutine call and return mechanisms  (cross-reference  PL/Language Translation and Execution)
      </topic>
      <topic importance='tier2'> I/O and interrupts
      </topic>
      <topic importance='tier2'> Heap vs. Static vs. Stack vs. Code segments
      </topic>
      <topic importance='tier2'> Shared memory multiprocessors/multicore organization
      </topic>
      <topic importance='tier2'> Introduction to SIMD vs. MIMD and the Flynn Taxonomy
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the organization of the classical von Neumann machine and its major functional units. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how an instruction is executed in a classical von Neumann machine, with extensions for threads, multiprocessor synchronization, and SIMD execution. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe instruction level parallelism and hazards, and how they are managed in typical processor pipelines. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Summarize how instructions are represented at both the machine level and in the context of a symbolic assembler. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Demonstrate how to map between  high-level  language patterns into assembly/machine language notations. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain different instruction formats, such as addresses per instruction and variable length vs. fixed length formats. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how subroutine calls are handled at the assembly level. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the basic concepts of interrupts and I/O operations. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write simple assembly language program segments. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Show how fundamental  high-level  programming constructs are implemented at the  machine-language  level. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MSOAA' name='Memory System Organization and Architecture'>
      <topic importance='tier2'> Storage systems and their technology
      </topic>
      <topic importance='tier2'> Memory hierarchy: importance of temporal and spatial locality
      </topic>
      <topic importance='tier2'> Main memory organization and operations
      </topic>
      <topic importance='tier2'> Latency, cycle time, bandwidth, and interleaving
      </topic>
      <topic importance='tier2'> Cache memories (address mapping, block size, replacement and store policy)
      </topic>
      <topic importance='tier2'> Multiprocessor cache consistency/Using the memory system for  inter-core  synchronization/atomic memory operations
      </topic>
      <topic importance='tier2'> Virtual memory (page table, TLB)
      </topic>
      <topic importance='tier2'> Fault handling and reliability
      </topic>
      <topic importance='tier2'> Error coding, data compression, and data integrity  (cross-reference  SF/Reliability through Redundancy)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Identify the main types of memory technology (e.g., SRAM, DRAM, Flash, magnetic disk) and their relative cost and performance. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the effect of memory latency on running time. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how the use of memory hierarchy (cache, virtual memory) is used to reduce the effective memory latency. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the principles of memory management. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the workings of a system with virtual memory management. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Compute Average Memory Access Time under a variety of cache and memory configurations and mixes of instruction and data references. </outcome>
    </knowledgeArea>
    <knowledgeArea id='IAC' name='Interfacing and Communication'>
      <topic importance='tier2'> I/O fundamentals: handshaking, buffering, programmed I/O,  interrupt-driven  I/O
      </topic>
      <topic importance='tier2'> Interrupt structures: vectored and prioritized, interrupt acknowledgment
      </topic>
      <topic importance='tier2'> External storage, physical organization, and drives
      </topic>
      <topic importance='tier2'> Buses: bus protocols, arbitration,  direct-memory  access (DMA)
      </topic>
      <topic importance='tier2'> Introduction to networks: communications networks as another layer of remote access
      </topic>
      <topic importance='tier2'> Multimedia support
      </topic>
      <topic importance='tier2'> RAID architectures
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how interrupts are used to implement I/O control and data transfers. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify various types of buses in a computer system. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe data access from a magnetic disk drive. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Compare common network organizations, such as ethernet/bus, ring, switched vs. routed. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify the  cross-layer  interfaces needed for multimedia access and presentation, from image fetch from remote storage, through transport over a communications network, to staging into local memory, and final presentation to a graphical display. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the advantages and limitations of RAID architectures. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FO' name='Functional Organization'>
      <topic importance='elective'> Implementation of simple datapaths, including instruction pipelining, hazard detection and resolution
      </topic>
      <topic importance='elective'> Control unit: hardwired realization vs. microprogrammed realization
      </topic>
      <topic importance='elective'> Instruction pipelining
      </topic>
      <topic importance='elective'> Introduction to  instruction-level  parallelism (ILP)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Compare alternative implementation of datapaths. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concept of control points and the generation of control signals using hardwired or microprogrammed implementations. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain basic instruction level parallelism using pipelining and the major hazards that may occur. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement a complete processor, including datapath and control. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Determine, for a given processor and memory system implementation, the average cycles per instruction. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MAAA' name='Multiprocessing and Alternative Architectures'>
      <topic importance='elective'> Power Law
      </topic>
      <topic importance='elective'> Example SIMD and MIMD instruction sets and architectures
      </topic>
      <topic importance='elective'> Interconnection networks (hypercube,  shuffle-exchange,  mesh, crossbar)
      </topic>
      <topic importance='elective'> Shared multiprocessor memory systems and memory consistency
      </topic>
      <topic importance='elective'> Multiprocessor cache coherence
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concept of parallel processing beyond the classical von Neumann model. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe alternative parallel architectures such as SIMD and MIMD. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of interconnection networks and characterize different approaches. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the special concerns that multiprocessing systems present with respect to memory management and describe how these are addressed. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the differences between memory backplane, processor memory interconnect, and remote memory via networks, their implications for access latency and impact on program performance. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PE' name='Performance Enhancements'>
      <topic importance='elective'> Superscalar architecture
      </topic>
      <topic importance='elective'> Branch prediction, Speculative execution,  Out-of-order  execution
      </topic>
      <topic importance='elective'> Prefetching
      </topic>
      <topic importance='elective'> Vector processors and GPUs
      </topic>
      <topic importance='elective'> Hardware support for multithreading
      </topic>
      <topic importance='elective'> Scalability
      </topic>
      <topic importance='elective'> Alternative architectures, such as VLIW/EPIC, and Accelerators and other kinds of  Special-Purpose  Processors
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe superscalar architectures and their advantages. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of branch prediction and its utility. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Characterize the costs and benefits of prefetching. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain speculative execution and identify the conditions that justify it. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the performance advantages that multithreading offered in an architecture along with the factors that make it difficult to derive maximum benefits from this approach. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the relevance of scalability to performance. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='CN' name='Computational Science'>
    <knowledgeArea id='ITMAS' name='Introduction to Modeling and Simulation'>
      <topic importance='tier1'> Models as abstractions of situations
      </topic>
      <topic importance='tier1'> Simulations as dynamic modeling
      </topic>
      <topic importance='tier1'> Simulation techniques and tools, such as physical simulations,  human-in-the-loop  guided simulations, and virtual reality
      </topic>
      <topic importance='tier1'> Foundational approaches to validating models (e.g., comparing a simulation’s output to real data or the output of another model)
      </topic>
      <topic importance='tier1'> Presentation of results in a form relevant to the system being modeled
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the concept of modeling and the use of abstraction that allows the use of a machine to solve a problem. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the relationship between modeling and simulation, i.e., thinking of simulation as dynamic modeling. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Create a simple, formal mathematical model of a  real-world  situation and use that model in a simulation. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Differentiate among the different types of simulations, including physical simulations,  human-guided  simulations, and virtual reality. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe several approaches to validating models. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Create a simple display of the results of a simulation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MAS' name='Modeling and Simulation'>
      <topic importance='elective'> Purpose of modeling and simulation including optimization; supporting decision making, forecasting, safety considerations; for training and education
      </topic>
      <topic importance='elective'> Tradeoffs including performance, accuracy, validity, and complexity
      </topic>
      <topic importance='elective'> The simulation process; identification of key characteristics or behaviors, simplifying assumptions; validation of outcomes
      </topic>
      <topic importance='elective'> Model building: use of mathematical formulas or equations, graphs, constraints; methodologies and techniques; use of time stepping for dynamic systems
      </topic>
      <topic importance='elective'> Formal models and modeling techniques: mathematical descriptions involving simplifying assumptions and avoiding detail. Examples of techniques include:
      </topic>
      <topic importance='elective'>Monte Carlo methods  o  Stochastic processes</topic>
      <topic importance='elective'>ueuing theory</topic>
      <topic importance='elective'>  Petri nets and colored Petri nets</topic>
      <topic importance='elective'>  Graph structures such as directed graphs, trees, networks</topic>
      <topic importance='elective'>Games, game theory, the modeling of things using game theory</topic>
      <topic importance='elective'>inear programming and its extensions</topic>
      <topic importance='elective'>  Dynamic programming</topic>
      <topic importance='elective'>Differential equations: ODE, PDE</topic>
      <topic importance='elective'>on-linear  techniques</topic>
      <topic importance='elective'>  State spaces and transitions</topic>
      <topic importance='elective'> Assessing and evaluating models and simulations in a variety of contexts; verification and validation of models and simulations
      </topic>
      <topic importance='elective'> Important application areas including health care and diagnostics, economics and finance, city and urban planning, science, and engineering
      </topic>
      <topic importance='elective'> Software in support of simulation and modeling; packages, languages
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain and give examples of the benefits of simulation and modeling in a range of important application areas. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate the ability to apply the techniques of modeling and simulation to a range of problem areas. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the constructs and concepts of a particular modeling approach. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Explain the difference between validation and verification of a model; demonstrate the difference with specific examples 1 . </outcome>
      <outcome importance='elective' mastery_level='assessment'>Verify and validate the results of a simulation. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate a simulation, highlighting the benefits and the drawbacks. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Choose an appropriate modeling approach for a given problem or situation. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare results from different simulations of the same situation and explain any differences. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Infer the behavior of a system from the results of a simulation of the system. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Extend or adapt an existing model to a new situation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='P' name='Processing'>
      <topic importance='elective'> Fundamental programming concepts:</topic>
      <topic importance='elective'> The concept of an algorithm consisting of a finite number of  well-defined  steps, each of which</topic>
      <topic importance='elective'> Examples of  well-known  algorithms such as sorting and searching.</topic>
      <topic importance='elective'> The concept of analysis as understanding what the problem is really asking, how a problem can be approached using an algorithm, and how information is represented so that a machine can process it.</topic>
      <topic importance='elective'> The development or identification of a workflow.</topic>
      <topic importance='elective'> The process of converting an algorithm to  machine-executable  code.</topic>
      <topic importance='elective'> Software processes including lifecycle models, requirements, design, implementation, verification and maintenance.</topic>
      <topic importance='elective'> Machine representation of data computer arithmetic.</topic>
      <topic importance='elective'> Numerical methods</topic>
      <topic importance='elective'> Algorithms for numerically fitting data (e.g., Newton’s method)</topic>
      <topic importance='elective'> Architectures for numerical computation, including parallel architectures</topic>
      <topic importance='elective'> Fundamental properties of parallel and distributed computation:</topic>
      <topic importance='elective'> Bandwidth.</topic>
      <topic importance='elective'>Latency.  o  Scalability.</topic>
      <topic importance='elective'>ranularity.</topic>
      <topic importance='elective'>  Parallelism including task, data, and event parallelism.</topic>
      <topic importance='elective'>  Parallel architectures including processor architectures, memory and caching.</topic>
        <topic importance='elective'>  Parallel programming paradigms including threading, message passing, event driven techniques, parallel software architectures, and MapReduce.</topic>
        <topic importance ='elective'>  Grid computing.</topic>
        <topic importance='elective'>  The impact of architecture on computational time.</topic>
        <topic importance='elective'>  Total time to science curve for parallelism: continuum of things.</topic>
      <topic importance='elective'> Computing costs, e.g., the cost of  re-computing  a value vs. the cost of storing and lookup.
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the characteristics and defining properties of algorithms and how they relate to machine processing. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze simple problem statements to identify relevant information and select appropriate processing to solve the problem. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify or sketch a workflow for an existing computational process such as the creation of a graph based on experimental data. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the process of converting an algorithm to  machine-executable  code. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize the phases of software development and compare several common lifecycle models. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how data is represented in a machine. Compare representations of integers to floating point numbers. Describe underflow, overflow, round off, and truncation errors in data representations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply standard numerical algorithms to solve ODEs and PDEs. Use computing systems to solve systems of equations. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the basic properties of bandwidth, latency, scalability and granularity. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the levels of parallelism including task, data, and event parallelism. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast parallel programming paradigms recognizing the strengths and weaknesses of each. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the issues impacting correctness and efficiency of a computation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design, code, test and debug programs for a parallel computation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='IV' name='Interactive Visualization'>
      <topic importance='elective'> Principles of data visualization
      </topic>
      <topic importance='elective'> Graphing and visualization algorithms
      </topic>
      <topic importance='elective'> Image processing techniques
      </topic>
      <topic importance='elective'> Scalability concerns
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Compare common computer interface mechanisms with respect to  ease-of-use,  learnability, and cost. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use standard APIs and tools to create visual displays of data, including graphs, charts, tables, and histograms. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe several approaches to using a computer as a means for interacting with and processing data. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Extract useful information from a dataset. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze and select visualization techniques for specific problems. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe issues related to scaling data analysis from small to large data sets. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DIAK' name='Data, Information, and Knowledge'>
      <topic importance='elective'> Content management models, frameworks, systems, design methods (as in IM. Information Management)
      </topic>
      <topic importance='elective'> Digital representations of content including numbers, text, images (e.g., raster and vector), video (e.g., QuickTime, MPEG2, MPEG4), audio (e.g., written score, MIDI, sampled digitized sound track) and animations; complex/composite/aggregate objects; FRBR
      </topic>
      <topic importance='elective'> Digital content creation/capture and preservation, including digitization, sampling, compression, conversion, transformation/translation, migration/emulation, crawling, harvesting
      </topic>
      <topic importance='elective'> Content structure / management, including digital libraries and static/dynamic/stream aspects for:</topic>
      <topic importance='elective'> Data: data structures, databases</topic>
      <topic importance='elective'> Information: document collections, multimedia pools, hyperbases (hypertext, hypermedia), catalogs, repositories</topic>
      <topic importance='elective'> Knowledge: ontologies, triple stores, semantic networks, rules</topic>
      <topic importance='elective'> Processing and pattern recognition, including indexing, searching (including: queries and query languages; central / federated / P2P), retrieving, clustering, classifying/categorizing, analyzing/mining/extracting, rendering, reporting, handling transactions
      </topic>
      <topic importance='elective'> User / society support for presentation and interaction, including browse, search, filter, route, visualize, share, collaborate, rate, annotate, personalize, recommend
      </topic>
      <topic importance='elective'> Modeling, design, logical and physical implementation, using relevant systems/software
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Identify all of the data, information, and knowledge elements and related organizations, for a computational science application. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how to represent data and information for processing. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe typical user requirements regarding that data, information, and knowledge. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Select a suitable system or software implementation to manage data, information, and knowledge. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List and describe the reports, transactions, and other processing needed for a computational science application. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast database management, information retrieval, and digital library systems with regard to handling typical computational science applications. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design a digital library for some computational science users/societies, with appropriate content and services. </outcome>
    </knowledgeArea>
    <knowledgeArea id='NA' name='Numerical Analysis'>
      <topic importance='elective'> Error, stability, convergence, including truncation and  round-off</topic>
      <topic importance='elective'> Function approximation including Taylor’s series, interpolation, extrapolation, and regression</topic>
      <topic importance='elective'> Numerical differentiation and integration (Simpson’s Rule, explicit and implicit methods)</topic>
      <topic importance='elective'> Differential equations (Euler’s Method, finite differences)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Define error, stability, machine precision concepts and the inexactness of computational approximations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement Taylor series, interpolation, extrapolation, and regression algorithms for approximating functions. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement algorithms for differentiation and integration. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement algorithms for solving differential equations. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='DS' name='Discrete Structures'>
    <knowledgeArea id='SRAF' name='Sets, Relations, and Functions'>
      <topic importance='tier1'> Sets</topic>
      <topic importance='tier1'> Venn diagrams</topic>
      <topic importance='tier1'> Union, intersection, complement</topic>
      <topic importance='tier1'> Cartesian product</topic>
      <topic importance='tier1'> Power sets</topic>
      <topic importance='tier1'> Cardinality of finite sets</topic>
      <topic importance='tier1'> Relations</topic>
      <topic importance='tier1'> Reflexivity, symmetry, transitivity</topic>
      <topic importance='tier1'> Equivalence relations, partial orders</topic>
      <topic importance='tier1'> Functions</topic>
      <topic importance='tier1'> Surjections, injections, bijections</topic>
      <topic importance='tier1'> Inverses</topic>
      <topic importance='tier1'> Composition</topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain with examples the basic terminology of functions, relations, and sets. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Perform the operations associated with sets, functions, and relations. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Relate practical examples to the appropriate set, function, or relation model, and interpret the associated operations and terminology in context. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BL' name='Basic Logic'>
      <topic importance='tier1'> Propositional logic  (cross-reference:  Propositional logic is also reviewed in IS/Knowledge Based Reasoning)
      </topic>
      <topic importance='tier1'> Logical connectives
      </topic>
      <topic importance='tier1'> Truth tables
      </topic>
      <topic importance='tier1'> Normal forms (conjunctive and disjunctive)
      </topic>
      <topic importance='tier1'> Validity of  well-formed  formula
      </topic>
      <topic importance='tier1'> Propositional inference rules (concepts of modus ponens and modus tollens)
      </topic>
      <topic importance='tier1'> Predicate logic</topic>
      <topic importance='tier1'> Universal and existential quantification</topic>
      <topic importance='tier1'> Limitations of propositional and predicate logic (e.g., expressiveness issues)</topic>
      <outcome importance='tier1' mastery_level='usage'>Convert logical statements from informal language to propositional and predicate logic expressions. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply formal methods of symbolic propositional and predicate logic, such as calculating validity of formulae and computing normal forms. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use the rules of inference to construct proofs in propositional and predicate logic. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Describe how symbolic logic can be used to model  real-life  situations or applications, including those arising in computing contexts such as software analysis (e.g., program correctness), database queries, and algorithms. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such as predicting the behavior of software or solving problems such as puzzles. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the strengths and limitations of propositional and predicate logic. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PT' name='Proof Techniques'>
      <topic importance='tier1'> Notions of implication, equivalence, converse, inverse, contrapositive, negation, and contradiction
      </topic>
      <topic importance='tier1'> The structure of mathematical proofs
      </topic>
      <topic importance='tier1'> Direct proofs
      </topic>
      <topic importance='tier1'> Disproving by counterexample
      </topic>
      <topic importance='tier1'> Proof by contradiction
      </topic>
      <topic importance='tier1'> Induction over natural numbers
      </topic>
      <topic importance='tier1'> Structural induction
      </topic>
      <topic importance='tier1'> Weak and strong induction (i.e., First and Second Principle of Induction)
      </topic>
      <topic importance='tier1'> Recursive mathematical definitions
      </topic>
      <topic importance='tier2'> Well orderings
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Identify the proof technique used in a given proof. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Outline the basic structure of each proof technique (direct proof, proof by contradiction, and induction) described in this unit. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly in the construction of a sound argument. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Determine which type of proof is best for a given problem. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Explain the parallels between ideas of mathematical and/or structural induction to recursion and recursively defined structures. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Explain the relationship between weak and strong induction and give examples of the appropriate use of each. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>State the  well-ordering  principle and its relationship to mathematical induction. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BOC' name='Basics of Counting'>
      <topic importance='tier1'> Counting arguments</topic>
      <topic importance='tier1'> Set cardinality and counting</topic>
      <topic importance='tier1'> Sum and product rule</topic>
      <topic importance='tier1'> Inclusion-exclusion  principle</topic>
      <topic importance='tier1'> Arithmetic and geometric progressions</topic>
      <topic importance='tier1'> The pigeonhole principle</topic>
      <topic importance='tier1'> Permutations and combinations</topic>
      <topic importance='tier1'> Basic definitions</topic>
      <topic importance='tier1'> Pascal’s identity</topic>
      <topic importance='tier1'> The binomial theorem</topic>
      <topic importance='tier1'> Solving recurrence relations  (cross-reference:  AL/Basic Analysis)</topic>
      <topic importance='tier1'> An example of a simple recurrence relation, such as Fibonacci numbers</topic>
      <topic importance='tier1'> Other examples, showing a variety of solutions</topic>
      <topic importance='tier1'> Basic modular arithmetic
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Apply counting arguments, including sum and product rules,  inclusion-exclusion  principle and arithmetic/geometric progressions. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply the pigeonhole principle in the context of a formal proof. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Compute permutations and combinations of a set, and interpret the meaning in the context of the particular application. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Map  real-world  applications to appropriate counting formalisms, such as determining the number of ways to arrange people around a table, subject to constraints on the seating arrangement, or the number of ways to determine certain hands in cards (e.g., a full house). </outcome>
      <outcome importance='tier1' mastery_level='usage'>Solve a variety of basic recurrence relations. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Analyze a problem to determine underlying recurrence relations. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Perform computations involving modular arithmetic. </outcome>
    </knowledgeArea>
    <knowledgeArea id='GAT' name='Graphs and Trees'>
      <topic importance='tier1'> Trees</topic>
      <topic importance='tier1'> Properties</topic>
      <topic importance='tier1'> Traversal strategies</topic>
      <topic importance='tier1'> Undirected graphs
      </topic>
      <topic importance='tier1'> Directed graphs
      </topic>
      <topic importance='tier1'> Weighted graphs
      </topic>
      <topic importance='tier2'> Spanning trees/forests
      </topic>
      <topic importance='tier2'> Graph isomorphism
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Illustrate by example the basic terminology of graph theory, as well as some of the properties and special cases of each type of graph/tree. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Demonstrate different traversal methods for trees and graphs, including  pre-,   post-,  and  in-order  traversal of trees. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Model  a variety of  real-world  problems in computer science using appropriate forms of graphs and trees, such as representing a network topology or the organization of a hierarchical file system. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Show how concepts from graphs and trees appear in data structures, algorithms, proof techniques (structural induction), and counting. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Explain how to construct a spanning tree of a graph. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Determine if two graphs are isomorphic. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DP' name='Discrete Probability'>
      <topic importance='tier1'> Finite probability space, events
      </topic>
      <topic importance='tier1'> Axioms of probability and probability measures
      </topic>
      <topic importance='tier1'> Conditional probability, Bayes’ theorem
      </topic>
      <topic importance='tier1'> Independence
      </topic>
      <topic importance='tier1'> Integer random variables (Bernoulli, binomial)
      </topic>
      <topic importance='tier1'> Expectation, including Linearity of Expectation
      </topic>
      <topic importance='tier2'> Variance
      </topic>
      <topic importance='tier2'> Conditional Independence
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Calculate probabilities of events and expectations of random variables for elementary problems such as games of chance. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Differentiate between dependent and independent events. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Identify a case of the binomial distribution and compute a probability using that distribution. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply Bayes theorem to determine conditional probabilities in a problem. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply the tools of probability to solve problems such as the average case analysis of algorithms or analyzing hashing. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Compute the variance for a given probability distribution. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Explain how events that are independent can be conditionally dependent (and  vice-versa).  Identify real- world examples of such cases. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='GV' name='Graphics and Visualization'>
    <knowledgeArea id='FC' name='Fundamental Concepts'>
      <topic importance='tier1'> Media applications including user interfaces, audio and video editing, game engines, cad, visualization, virtual reality
      </topic>
      <topic importance='tier1'> Digitization of analog data, resolution, and the limits of human perception, e.g., pixels for visual display, dots for laser printers, and samples for audio (HCI/Foundations)
      </topic>
      <topic importance='tier1'> Use of standard APIs for the construction of UIs and display of standard media formats (see HCI/GUI construction)
      </topic>
      <topic importance='tier1'> Standard media formats, including lossless and lossy formats
      </topic>
      <topic importance='tier2'> Additive and subtractive color models (CMYK and RGB) and why these provide a range of colors
      </topic>
      <topic importance='tier2'> Tradeoffs between storing data and  re-computing  data as embodied by vector and raster representations of images
      </topic>
      <topic importance='tier2'> Animation as a sequence of still images
      </topic>
      <topic importance='elective'> Double buffering
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Identify common uses of digital presentation to humans (e.g., computer graphics, sound). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain in general terms how analog signals can be reasonably represented by discrete samples, for example, how images can be represented by pixels. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain how the limits of human perception affect choices about the digital representation of analog signals. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Construct a simple user interface using a standard API. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the differences between lossy and lossless image compression techniques, for example as reflected in common graphics image file formats such as JPG, PNG, MP3, MP4, and GIF. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe color models and their use in graphics display devices. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the tradeoffs between storing information vs. storing enough information to reproduce the information, as in the difference between vector and raster rendering. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the basic process of producing continuous motion from a sequence of discrete frames (sometimes called “flicker fusion”). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how  double-buffering  can remove flicker from animation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BR' name='Basic Rendering'>
      <topic importance='elective'> Rendering in nature, e.g., the emission and scattering of light and its relation to numerical integration
      </topic>
      <topic importance='elective'> Forward and backward rendering (i.e.,  ray-casting  and rasterization)
      </topic>
      <topic importance='elective'> Polygonal representation
      </topic>
      <topic importance='elective'> Basic radiometry, similar triangles, and projection model
      </topic>
      <topic importance='elective'> Affine and coordinate system transformations
      </topic>
      <topic importance='elective'> Ray tracing
      </topic>
      <topic importance='elective'> Visibility and occlusion, including solutions to this problem such as depth buffering, Painter’s algorithm, and ray tracing
      </topic>
      <topic importance='elective'> The forward and backward rendering equation
      </topic>
      <topic importance='elective'> Simple triangle rasterization
      </topic>
      <topic importance='elective'> Rendering with a  shader-based  API
      </topic>
      <topic importance='elective'> Texture mapping, including minification and magnification (e.g., trilinear  MIP-mapping)
      </topic>
      <topic importance='elective'> Application of spatial data structures to rendering
      </topic>
      <topic importance='elective'> Sampling and  anti-aliasing
      </topic>
      <topic importance='elective'> Scene graphs and the graphics pipeline
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the light transport problem and its relation to numerical integration i.e., light is emitted, scatters around the scene, and is measured by the eye. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the basic graphics pipeline and how forward and backward rendering factor in this. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create a program to display 3D models of simple graphics images. </outcome>
      <outcome importance='elective' mastery_level='usage'>Derive linear perspective from similar triangles by converting points (x, y, z) to points (x/z, y/z, 1). </outcome>
      <outcome importance='elective' mastery_level='usage'>Obtain   and   points by applying affine transformations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply   coordinate system and the changes required to extend 2D transformation operations to handle transformations in 3D. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Contrast forward and backward rendering. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept and applications of texture mapping, sampling, and  anti-aliasing.  </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the ray tracing/rasterization duality for the visibility problem. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement simple procedures that perform transformation and clipping operations on simple   images. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a simple  real-time  renderer using a rasterization API (e.g., OpenGL) using vertex buffers and shaders. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast the different rendering techniques. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compute space requirements based on resolution and color coding. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compute time requirements based on refresh rates, rasterization techniques. </outcome>
    </knowledgeArea>
    <knowledgeArea id='GM' name='Geometric Modeling'>
      <topic importance='elective'> Basic geometric operations such as intersection calculation and proximity tests
      </topic>
      <topic importance='elective'> Volumes, voxels, and  point-based  representations
      </topic>
      <topic importance='elective'> Parametric polynomial curves and surfaces
      </topic>
      <topic importance='elective'> Implicit representation of curves and surfaces
      </topic>
      <topic importance='elective'> Approximation techniques such as polynomial curves, Bezier curves, spline curves and surfaces, and non- uniform rational basis (NURB) spines, and level set method
      </topic>
      <topic importance='elective'> Surface representation techniques including tessellation, mesh representation, mesh fairing, and mesh generation techniques such as Delaunay triangulation, marching cubes
      </topic>
      <topic importance='elective'> Spatial subdivision techniques
      </topic>
      <topic importance='elective'> Procedural models such as fractals, generative modeling, and  L-systems
      </topic>
      <topic importance='elective'> Graftals, cross referenced with programming languages (grammars to generated pictures)
      </topic>
      <topic importance='elective'> Elastically deformable and freeform deformable models
      </topic>
      <topic importance='elective'> Subdivision surfaces
      </topic>
      <topic importance='elective'> Multiresolution modeling
      </topic>
      <topic importance='elective'> Reconstruction
      </topic>
      <topic importance='elective'> Constructive Solid Geometry (CSG) representation
      </topic>
      <outcome importance='elective' mastery_level='usage'>Represent curves and surfaces using both implicit and parametric forms. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create simple polyhedral models by surface tessellation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Generate a mesh representation from an implicit surface. </outcome>
      <outcome importance='elective' mastery_level='usage'>Generate a fractal model or terrain using a procedural method. </outcome>
      <outcome importance='elective' mastery_level='usage'>Generate a mesh from data points acquired with a laser scanner. </outcome>
      <outcome importance='elective' mastery_level='usage'>Construct CSG models from simple primitives, such as cubes and quadric surfaces. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Contrast modeling approaches with respect to space and time complexity and quality of image. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AR' name='Advanced Rendering'>
      <topic importance='elective'>Solutions and approximations to the rendering equation, for example:
      </topic>
      <topic importance='elective'>istribution ray tracing and path tracing</topic>
      <topic importance='elective'>  Photon mapping</topic>
      <topic importance='elective'>  Bidirectional path tracing</topic>
      <topic>Reyes (micropolygon) rendering</topic>
      <topic importance='elective'>etropolis light transport
      </topic>
      <topic importance='elective'> Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on rendering
      </topic>
      <topic importance='elective'> Shadow mapping
      </topic>
      <topic importance='elective'> Occlusion culling
      </topic>
      <topic importance='elective'> Bidirectional Scattering Distribution function (BSDF) theory and microfacets
      </topic>
      <topic importance='elective'> Subsurface scattering
      </topic>
      <topic importance='elective'> Area light sources
      </topic>
      <topic importance='elective'> Hierarchical depth buffering
      </topic>
      <topic importance='elective'> The Light Field,  image-based  rendering
      </topic>
      <topic importance='elective'> Non-photorealistic  rendering
      </topic>
      <topic importance='elective'> GPU architecture
      </topic>
      <topic importance='elective'> Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Demonstrate how an algorithm estimates a solution to the rendering equation. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Prove the properties of a rendering algorithm, e.g., complete, consistent, and unbiased. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze the bandwidth and computation demands of a simple algorithm. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a  non-trivial  shading algorithm (e.g., toon shading, cascaded shadow maps) under a rasterization API. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss how a particular artistic technique might be implemented in a renderer. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how to recognize the graphics techniques used to create a particular image. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement any of the specified graphics techniques using a primitive graphics system at the individual pixel level. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a ray tracer for scenes using a simple (e.g., Phong model) BRDF plus reflection and refraction. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CA' name='Computer Animation'>
      <topic importance='elective'> Forward and inverse kinematics
      </topic>
      <topic importance='elective'> Collision detection and response
      </topic>
      <topic importance='elective'> Procedural animation using noise, rules (boids/crowds), and particle systems
      </topic>
      <topic importance='elective'> Skinning algorithms
      </topic>
      <topic importance='elective'> Physics based motions including rigid body dynamics, physical particle systems,  mass-spring  networks for cloth and flesh and hair
      </topic>
      <topic importance='elective'> Key-frame  animation
      </topic>
      <topic importance='elective'> Splines
      </topic>
      <topic importance='elective'> Data structures for rotations, such as quaternions
      </topic>
      <topic importance='elective'> Camera animation
      </topic>
      <topic importance='elective'> Motion capture
      </topic>
      <outcome importance='elective' mastery_level='usage'>Compute the location and orientation of model parts using a forward kinematic approach. </outcome>
      <outcome importance='elective' mastery_level='usage'>Compute the orientation of articulated parts of a model from a location and orientation using an inverse kinematic approach. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Describe the tradeoffs in different representations of rotations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement the spline interpolation method for producing  in-between  positions and orientations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement algorithms for physical modeling of particle dynamics using simple Newtonian mechanics, for example Witkin &amp; Kass, snakes and worms, symplectic Euler, Stormer/Verlet, or midpoint Euler methods. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the basic ideas behind some methods for fluid dynamics for modeling ballistic trajectories, for example for splashes, dust, fire, or smoke. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use common animation software to construct simple organic forms using metaball and skeleton. </outcome>
    </knowledgeArea>
    <knowledgeArea id='V' name='Visualization'>
      <topic importance='elective'> Visualization of 2D/3D scalar fields: color mapping, isosurfaces
      </topic>
      <topic importance='elective'> Direct volume data rendering:  ray-casting,  transfer functions, segmentation
      </topic>
      <topic importance='elective'> Visualization of: </topic>
      <topic importance='elective'>Vector fields and flow data</topic>
      <topic importance='elective'>ime-varying  data</topic>
      <topic importance='elective'>  High-dimensional  data: dimension reduction, parallel coordinates,</topic>
      <topic importance='elective'>  Non-spatial  data:  multi-variate,  tree/graph structured, text</topic>
      <topic importance='elective'> Perceptual and cognitive foundations that drive visual abstractions
      </topic>
      <topic importance='elective'> Visualization design
      </topic>
      <topic importance='elective'> Evaluation of visualization methods
      </topic>
      <topic importance='elective'> Applications of visualization
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the basic algorithms for scalar and vector visualization. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Describe the tradeoffs of visualization algorithms in terms of accuracy and performance. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Propose a suitable visualization design for a particular combination of data characteristics and application tasks. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze the effectiveness of a given visualization for a particular task. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Design a process to evaluate the utility of a visualization algorithm or system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Recognize a variety of applications of visualization including representations of scientific, medical, and mathematical data; flow visualization; and spatial analysis. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='HCI' name='Human-Computer Interaction'>
    <knowledgeArea id='F' name='Foundations'>
      <topic importance='tier1'> Contexts for HCI (anything with a user interface, e.g., webpage, business applications, mobile applications, and games)
      </topic>
      <topic importance='tier1'> Processes for  user-centered  development, e.g., early focus on users, empirical testing, iterative design
      </topic>
      <topic importance='tier1'> Different measures for evaluation, e.g., utility, efficiency, learnability, user satisfaction
      </topic>
      <topic importance='tier1'> Usability heuristics and the principles of usability testing
      </topic>
      <topic importance='tier1'> Physical capabilities that inform interaction design, e.g., color perception, ergonomics
      </topic>
      <topic importance='tier1'> Cognitive models that inform interaction design, e.g., attention, perception and recognition, movement, and memory; gulfs of expectation and execution
      </topic>
      <topic importance='tier1'> Social models that inform interaction design, e.g., culture, communication, networks and organizations
      </topic>
      <topic importance='tier1'> Principles of good design and good designers; engineering tradeoffs
      </topic>
      <topic importance='tier1'> Accessibility, e.g., interfaces for  differently-abled  populations (e.g., blind,  motion-impaired)
      </topic>
      <topic importance='tier1'> Interfaces for  differently-aged  population groups (e.g., children, 80+)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss why  human-centered  software development is important. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Summarize the basic precepts of psychological and social interaction. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Develop and use a conceptual vocabulary for analyzing human interaction with software: affordance, conceptual model, feedback, and so forth. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Define a  user-centered  design process that explicitly takes account of the fact that the user is not like the developer or their acquaintances. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Create and conduct a simple usability test for an existing software application. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DI' name='Designing Interaction'>
      <topic importance='tier2'> Principles of graphical user interfaces (GUIs)
      </topic>
      <topic importance='tier2'> Elements of visual design (layout, color, fonts, labeling)
      </topic>
      <topic importance='tier2'> Task analysis, including qualitative aspects of generating task analytic models
      </topic>
      <topic importance='tier2'> Low-fidelity  (paper) prototyping
      </topic>
      <topic importance='tier2'> Quantitative evaluation techniques, e.g.,  keystroke-level  evaluation
      </topic>
      <topic importance='tier2'> Help and documentation
      </topic>
      <topic importance='tier2'> Handling human/system failure
      </topic>
      <topic importance='tier2'> User interface standards
      </topic>
      <outcome importance='tier2' mastery_level='assessment'>For an identified user group, undertake and document an analysis of their needs. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Create a simple application, together with help and documentation, that supports a graphical user interface. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Conduct a quantitative evaluation and discuss/report the results. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss at least one national or international user interface design standard. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PIS' name='Programming Interactive Systems'>
      <topic importance='elective'> Software Architecture Patterns, e.g.,  Model-View  controller; command objects, online, offline (cross reference PL/Event Driven and Reactive Programming, where MVC is used in the context of  event-driven  programming)
      </topic>
      <topic importance='elective'> Interaction Design Patterns: visual hierarchy, navigational distance
      </topic>
      <topic importance='elective'> Event management and user interaction
      </topic>
      <topic importance='elective'> Geometry management  (cross-reference  GV/Geometric Modelling)
      </topic>
      <topic importance='elective'> Choosing interaction styles and interaction techniques
      </topic>
      <topic importance='elective'> Presenting information: navigation, representation, manipulation
      </topic>
      <topic importance='elective'> Interface animation techniques (e.g., scene graphs)
      </topic>
      <topic importance='elective'> Widget classes and libraries
      </topic>
      <topic importance='elective'> Modern GUI libraries (e.g. iOS, Android, JavaFX) GUI builders and UI programming environments (cross- reference PBD/Mobile Platforms)
      </topic>
      <topic importance='elective'> Declarative Interface Specification: Stylesheets and DOMs
      </topic>
      <topic importance='elective'> Data-driven  applications  (database-backed  web pages)
      </topic>
      <topic importance='elective'> Cross-platform  design
      </topic>
      <topic importance='elective'> Design for  resource-constrained  devices (e.g. small, mobile devices)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the importance of  Model-View  controller to interface programming. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create an application with a modern graphical user interface. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify commonalities and differences in UIs across different platforms. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain and use GUI programming concepts: event handling,  constraint-based  layout management, etc. </outcome>
    </knowledgeArea>
    <knowledgeArea id='UDAT' name='User-Centered  Design and Testing'>
      <topic importance='elective'> Approaches to, and characteristics of, the design process
      </topic>
      <topic importance='elective'> Functionality and usability requirements  (cross-reference  to SE/Requirements Engineering)
      </topic>
      <topic importance='elective'> Techniques for gathering requirements, e.g., interviews, surveys, ethnographic and contextual enquiry
      </topic>
      <topic importance='elective'> Techniques and tools for the analysis and presentation of requirements, e.g., reports, personas
      </topic>
      <topic importance='elective'> Prototyping techniques and tools, e.g., sketching, storyboards,  low-fidelity  prototyping, wireframes
      </topic>
      <topic importance='elective'> Evaluation without users, using both qualitative and quantitative techniques, e.g., walkthroughs, GOMS,  expert-based  analysis, heuristics, guidelines, and standards
      </topic>
      <topic importance='elective'> Evaluation with users, e.g., observation,  think-aloud,  interview, survey, experiment
      </topic>
      <topic importance='elective'> Challenges to effective evaluation, e.g., sampling, generalization
      </topic>
      <topic importance='elective'> Reporting the results of evaluations
      </topic>
      <topic importance='elective'> Internationalization, designing for users from other cultures,  cross-cultural
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain how  user-centered  design complements other software process models. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use  lo-fi  (low fidelity) prototyping techniques to gather, and report, user responses. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Choose appropriate methods to support the development of a specific UI. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Use a variety of techniques to evaluate a given UI. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare the constraints and benefits of different evaluative methods. </outcome>
    </knowledgeArea>
    <knowledgeArea id='NIT' name='New Interactive Technologies'>
      <topic importance='elective'> Choosing interaction styles and interaction techniques
      </topic>
      <topic importance='elective'> Representing information to users: navigation, representation, manipulation
      </topic>
      <topic importance='elective'>Approaches to design, implementation and evaluation of  non-mouse  interaction
      </topic>
      <topic importance='elective'>ouch and  multi-touch  interfaces</topic>
      <topic importance='elective'>  Shared, embodied, and large interfaces</topic>
      <topic importance='elective'>New input modalities (such as sensor and location data)</topic>
      <topic importance='elective'>ew Windows, e.g., iPhone, Android</topic>
      <topic importance='elective'>  Speech recognition and natural language processing (cross reference IS/Natural Language Processing)</topic>
      <topic importance='elective'>Wearable and tangible interfaces</topic>
      <topic importance='elective'>ersuasive interaction and emotion</topic>
      <topic importance='elective'>Ubiquitous and  context-aware  interaction technologies (Ubicomp)</topic>
      <topic importance='elective'>ayesian inference (e.g. predictive text, guided pointing)</topic>
      <topic importance='elective'>  Ambient/peripheral display and interaction</topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe when  non-mouse  interfaces are appropriate. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Understand the interaction possibilities beyond  mouse-and-pointer  interfaces. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Discuss the advantages (and disadvantages) of  non-mouse  interfaces. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CAC' name='Collaboration and Communication'>
      <topic importance='elective'> Asynchronous group communication, e.g.,  e-mail,  forums, social networks</topic>
      <topic importance='elective'> Synchronous group communication, e.g., chat rooms, conferencing, online games</topic>
      <topic importance='elective'> Social media, social computing, and social network analysis
      </topic>
      <topic importance='elective'> Online collaboration, 'smart' spaces, and social coordination aspects of workflow technologies
      </topic>
      <topic importance='elective'> Online communities
      </topic>
      <topic importance='elective'> Software characters and intelligent agents, virtual worlds and avatars  (cross-reference  IS/Agents)
      </topic>
      <topic importance='elective'> Social psychology
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the difference between synchronous and asynchronous communication. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare the HCI issues in individual interaction with group interaction. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss several issues of social concern raised by collaborative software. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the HCI issues in software that embodies human intention. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SMFH' name='Statistical Methods for HCI'>
      <topic importance='elective'> t-tests
      </topic>
      <topic importance='elective'> ANOVA
      </topic>
      <topic importance='elective'> Randomization  (non-parametric)  testing, within vs.  between-subjects  design
      </topic>
      <topic importance='elective'> Calculating effect size
      </topic>
      <topic importance='elective'> Exploratory data analysis
      </topic>
      <topic importance='elective'> Presenting statistical data
      </topic>
      <topic importance='elective'> Combining qualitative and quantitative results
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain basic statistical concepts and their areas of application. </outcome>
      <outcome importance='elective' mastery_level='usage'>Extract and articulate the statistical arguments used in papers that quantitatively report user studies. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design a user study that will yield quantitative results. </outcome>
      <outcome importance='elective' mastery_level='usage'>Conduct and report on a study that utilizes both qualitative and quantitative evaluation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='HFAS' name='Human Factors and Security'>
      <topic importance='elective'> Applied psychology and security policies
      </topic>
      <topic importance='elective'> Security economics
      </topic>
      <topic importance='elective'> Regulatory environments – responsibility, liability and  self-determination
      </topic>
      <topic importance='elective'> Organizational vulnerabilities and threats
      </topic>
      <topic importance='elective'> Usability design and security
      </topic>
      <topic importance='elective'> Pretext, impersonation and fraud, e.g., phishing and spear phishing  (cross-reference  IAS/Threats and Attacks)
      </topic>
      <topic importance='elective'> Trust, privacy and deception
      </topic>
      <topic importance='elective'> Biometric authentication (camera, voice)
      </topic>
      <topic importance='elective'> Identity management
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concepts of phishing and spear phishing, and how to recognize them. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Describe the issues of trust in interface design with an example of a high and low trust system. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Design a user interface for a security mechanism. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of identity management and its importance. </outcome>
      <outcome importance='elective' mastery_level='usage'>Analyze a security policy and/or procedures to show where they consider, or fail to consider, human factors. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DH' name='Design-Oriented  HCI'>
      <topic importance='elective'> Intellectual styles and perspectives to technology and its interfaces
      </topic>
      <topic importance='elective'> Consideration of HCI as a design discipline</topic>
      <topic importance='elective'> Sketching</topic>
      <topic importance='elective'> Participatory design</topic>
      <topic importance='elective'> Critically reflective HCI</topic>
      <topic importance='elective'> Critical technical practice</topic>
      <topic importance='elective'> Technologies for political activism</topic>
      <topic importance='elective'> Philosophy of user experience</topic>
      <topic importance='elective'> Ethnography and ethnomethodology</topic>
      <topic importance='elective'> Indicative domains of application</topic>
      <topic importance='elective'> Sustainability</topic>
      <topic importance='elective'> Arts-informed  computing</topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain what is meant by “HCI is a  design-oriented  discipline”. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Detail the processes of design appropriate to specific design orientations. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply a variety of design methods to a given problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MAAVR' name='Mixed, Augmented and Virtual Reality'>
      <topic importance='elective'> Output</topic>
      <topic importance='elective'> Sound</topic>
      <topic importance='elective'> Stereoscopic display</topic>
      <topic importance='elective'> Force feedback simulation, haptic devices</topic>
      <topic importance='elective'> User input</topic>
      <topic importance='elective'> Viewer and object tracking</topic>
      <topic importance='elective'> Pose and gesture recognition</topic>
      <topic importance='elective'> Accelerometers</topic>
      <topic importance='elective'> Fiducial markers</topic>
      <topic importance='elective'> User interface issues</topic>
      <topic importance='elective'> Physical modelling and rendering</topic>
      <topic importance='elective'> Physical simulation: collision detection &amp; response, animation</topic>
      <topic importance='elective'> Visibility computation</topic>
      <topic importance='elective'> Time-critical  rendering, multiple levels of details (LOD)</topic>
      <topic importance='elective'> System architectures</topic>
      <topic importance='elective'> Game engines</topic>
      <topic importance='elective'> Mobile augmented reality</topic>
      <topic importance='elective'> Flight simulators</topic>
      <topic importance='elective'> CAVEs</topic>
      <topic importance='elective'> Medical imaging</topic>
      <topic importance='elective'> Networking</topic>
      <topic importance='elective'> p2p,  client-server,  dead reckoning, encryption, synchronization</topic>
      <topic importance='elective'> Distributed collaboration</topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the optical model realized by a computer graphics system to synthesize stereoscopic view. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the principles of different viewer tracking technologies. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the differences between geometry- and  image-based  virtual reality. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the issues of user action synchronization and data consistency in a networked environment. </outcome>
      <outcome importance='elective' mastery_level='usage'>Determine the basic requirements on interface, hardware, and software configurations of a VR system for a specified application. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe several possible uses for games engines, including their potential and their limitations. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='IAS' name='Information Assurance and Security'>
    <knowledgeArea id='FCIS' name='Foundational Concepts in Security'>
      <topic importance='tier1'> CIA (Confidentiality, Integrity, Availability)
      </topic>
      <topic importance='tier1'> Concepts of risk, threats, vulnerabilities, and attack vectors (cros- reference SE/Software Project Management/Risk)
      </topic>
      <topic importance='tier1'> Authentication and authorization, access control (mandatory vs. discretionary)
      </topic>
      <topic importance='tier1'> Concept of trust and trustworthiness
      </topic>
      <topic importance='tier1'> Ethics (responsible disclosure).  (cross-reference  SP/Professional Ethics/Accountability, responsibility and liability)
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Analyze the tradeoffs of balancing key security properties (Confidentiality, Integrity, and Availability). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the concepts of risk, threats, vulnerabilities and attack vectors (including the fact that there is no such thing as perfect security). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the concepts of authentication, authorization, access control. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the concept of trust and trustworthiness. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe important ethical issues to consider in computer security, including ethical issues associated with fixing or not fixing vulnerabilities and disclosing or not disclosing vulnerabilities. </outcome>
    </knowledgeArea>
    <knowledgeArea id='POSD' name='Principles of Secure Design'>
      <topic importance='tier1'> Least privilege and isolation  (cross-reference  OS/Security and Protection/Policy/mechanism separation and SF/Virtualization and Isolation/Rationale for protection and predictable performance and PL/Language Translation and Execution/Memory management)
      </topic>
      <topic importance='tier1'> Fail-safe  defaults  (cross-reference  SE/Software Construction/ Coding practices: techniques, idioms/patterns, mechanisms for building quality programs and SDF/Development Methods/Programming correctness)
      </topic>
      <topic importance='tier1'> Open design  (cross-reference  SE/Software Evolution/ Software development in the context of large, pre- existing code bases)
      </topic>
      <topic importance='tier1'> End-to-end  security  (cross-reference  SF/Reliability through Redundancy/ How errors increase the longer the distance between the communicating entities; the  end-to-end  principle)
      </topic>
      <topic importance='tier1'> Defense in depth (e.g., defensive programming, layered defense)
      </topic>
      <topic importance='tier1'> Security by design  (cross-reference  SE/Software Design/System design principles)
      </topic>
      <topic importance='tier1'> Tensions between security and other design goals
      </topic>
      <topic importance='tier2'> Complete mediation
      </topic>
      <topic importance='tier2'> Use of vetted security components
      </topic>
      <topic importance='tier2'> Economy of mechanism (reducing trusted computing base, minimize attack surface)  (cross-reference  SE/Software Design/System design principles and SE/Software Construction/Development context: “green field” vs. existing code base)
      </topic>
      <topic importance='tier2'> Usable security  (cross-reference  HCI/Foundations/Cognitive models that inform interaction design)
      </topic>
      <topic importance='tier2'> Security composability
      </topic>
      <topic importance='tier2'> Prevention, detection, and deterrence  (cross-reference  SF/Reliability through Redundancy/Distinction between bugs and faults and NC/Reliable Data Delivery/Error control and NC/Reliable Data Delivery/Flow control)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the principle of least privilege and isolation as applied to system design. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Summarize the principle of  fail-safe  and  deny-by-default.  </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the implications of relying on open design or the secrecy of design for security. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the goals of  end-to-end  data security. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the benefits of having multiple layers of defenses. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>For each stage in the lifecycle of a product, describe what security considerations should be evaluated. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the cost and tradeoffs associated with designing security into a product. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the concept of mediation and the principle of complete mediation. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe standard components for security operations, and explain the benefits of their use instead of re- inventing fundamentals operations. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the concept of trusted computing including trusted computing base and attack surface and the principle of minimizing trusted computing base. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the importance of usability in security mechanism design. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe security issues that arise at boundaries between multiple components. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify the different roles of prevention mechanisms and detection/deterrence mechanisms. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DP' name='Defensive Programming'>
      <topic importance='tier1'> Input validation and data sanitization  (cross-reference  SDF/Development Methods/Program Correctness)
      </topic>
      <topic importance='tier1'> Choice of programming language and  type-safe  languages
      </topic>
      <topic importance='tier1'> Examples of input validation and data sanitization errors  (cross-reference  SDF/Development Methods/Program Correctness and SE/Software Construction/Coding Practices)</topic>
      <topic importance='tier1'>Buffer overflows</topic>
      <topic importance='tier1'>nteger errors</topic>
      <topic importance='tier1'>  SQL injection</topic>
      <topic importance='tier1'>  XSS vulnerability</topic>
      <topic importance='tier1'> Race conditions  (cross-reference  SF/Parallelism/Parallel programming and PD/Parallel Architecture/Shared vs. distributed memory and PD/Communication and Coordination/Shared Memory and PD/Parallelism Fundamentals/Programming errors not found in sequential programming)
      </topic>
      <topic importance='tier1'> Correct handling of exceptions and unexpected behaviors  (cross-reference  SDF/Development Methods/program correctness)
      </topic>
      <topic importance='tier2'> Correct usage of  third-party  components  (cross-reference  SDF/Development Methods/program correctness and Operating System Principles/Concepts of application program interfaces (APIs)
      </topic>
      <topic importance='tier2'> Effectively deploying security updates  (cross-reference  OS/Security and Protection/Security methods and devices)
      </topic>
      <topic importance='elective'> Information flow control
      </topic>
      <topic importance='elective'> Correctly generating randomness for security purposes
      </topic>
      <topic importance='elective'> Mechanisms for detecting and mitigating input and data sanitization errors
      </topic>
      <topic importance='elective'> Fuzzing
      </topic>
      <topic importance='elective'> Static analysis and dynamic analysis
      </topic>
      <topic importance='elective'> Program verification
      </topic>
      <topic importance='elective'> Operating system support (e.g., address space randomization, canaries)
      </topic>
      <topic importance='elective'> Hardware support (e.g., DEP, TPM)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain why input validation and data sanitization is necessary in the face of adversarial control of the input channel. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain why you might choose to develop a program in a  type-safe  language like Java, in contrast to an unsafe programming language like C/C++. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Classify common input validation errors, and write correct input validation code. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Demonstrate using a  high-level  programming language how to prevent a race condition from occurring and how to handle an exception. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Demonstrate the identification and graceful handling of error conditions. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the risks with misusing interfaces with  third-party  code and how to correctly use  third-party  code. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the need to update software to fix security vulnerabilities and the lifecycle management of the fix. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List examples of direct and indirect information flows. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the role of random numbers in security, beyond just cryptography (e.g. password generation, randomized algorithms to avoid algorithmic denial of service attacks). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the different types of mechanisms for detecting and mitigating data sanitization errors. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate how programs are tested for input handling errors. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use static and dynamic tools to identify programming faults. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how memory architecture is used to protect runtime attacks. </outcome>
    </knowledgeArea>
    <knowledgeArea id='TAA' name='Threats and Attacks'>
      <topic importance='tier2'> Attacker goals, capabilities, and motivations (such as underground economy, digital espionage, cyberwarfare, insider threats, hacktivism, advanced persistent threats)
      </topic>
      <topic importance='tier2'> Examples of malware (e.g., viruses, worms, spyware, botnets, Trojan horses or rootkits)
      </topic>
      <topic importance='tier2'> Denial of Service (DoS) and Distributed Denial of Service (DDoS)
      </topic>
      <topic importance='tier2'> Social engineering (e.g., phishing)  (cross-reference  SP/Social Context/Social implications of computing in a networked world and HCI/Designing Interaction/Handling human/system failure)
      </topic>
      <topic importance='elective'> Attacks on privacy and anonymity  (cross-reference  HCI/Foundations/Social models that inform interaction design: culture, communication, networks and organizations  (cross-reference  SP/Privacy and Civil  Liberties/technology-based  solutions for privacy protection)
      </topic>
      <topic importance='elective'> Malware/unwanted communication such as covert channels and steganography
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe likely attacker types against a particular system. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the limitations of malware countermeasures (e.g.,  signature-based  detection, behavioral detection). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify instances of social engineering attacks and Denial of Service attacks. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss how Denial of Service attacks can be identified and mitigated. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe risks to privacy and anonymity in commonly used applications. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concepts of covert channels and other data leakage procedures. </outcome>
    </knowledgeArea>
    <knowledgeArea id='NS' name='Network Security'>
      <topic importance='tier2'> Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic redirection,  man-in-the-middle,  message integrity attacks, routing attacks, and traffic analysis)
      </topic>
      <topic importance='tier2'> Use of cryptography for data and network security
      </topic>
      <topic importance='tier2'> Architectures for secure networks (e.g., secure channels, secure routing protocols, secure DNS, VPNs, anonymous communication protocols, isolation)
      </topic>
      <topic importance='tier2'> Defense mechanisms and countermeasures (e.g., network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots, tracebacks)
      </topic>
      <topic importance='elective'> Security for wireless, cellular networks  (cross-reference  NC/Mobility/Principles of cellular networks;  cross-reference  NC/Mobility/802.11)
      </topic>
      <topic importance='elective'> Other  non-wired  networks (e.g., ad hoc, sensor, and vehicular networks)
      </topic>
      <topic importance='elective'> Censorship resistance
      </topic>
      <topic importance='elective'> Operational network security management (e.g., configure network access control)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the different categories of network threats and attacks. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the architecture for public and private key cryptography and how public key infrastructure (PKI) supports network security. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe virtues and limitations of security technologies at each layer of the network stack. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify the appropriate defense mechanism(s) and its limitations given a network threat. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss security properties and limitations of other  non-wired  networks. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the additional threats faced by  non-wired  networks. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe threats that can and cannot be protected against using secure communication channels. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize defenses against network censorship. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Diagram a network for security. </outcome>
    </knowledgeArea>
    <knowledgeArea id='C' name='Cryptography'>
      <topic importance='tier2'> Basic Cryptography Terminology covering notions pertaining to the different (communication) partners, secure/unsecure channel, attackers and their capabilities, encryption, decryption, keys and their characteristics, signatures
      </topic>
      <topic importance='tier2'> Cipher types (e.g., Caesar cipher, affine cipher) together with typical attack methods such as frequency analysis
      </topic>
      <topic importance='tier2'> Public Key Infrastructure support for digital signature and encryption and its challenges
      </topic>
      <topic importance='elective'> Mathematical Preliminaries essential for cryptography, including topics in linear algebra, number theory, probability theory, and statistics
      </topic>
      <topic importance='elective'> Cryptographic primitives:</topic>
      <topic importance='elective'> pseudo-random  generators and stream ciphers</topic>
      <topic importance='elective'> block ciphers  (pseudo-random  permutations), e.g., AES</topic>
      <topic importance='elective'> pseudo-random  functions</topic>
      <topic importance='elective'> hash functions, e.g., SHA2, collision resistance</topic>
      <topic importance='elective'> message authentication codes</topic>
      <topic importance='elective'> key derivations functions</topic>
      <topic importance='elective'> Symmetric key cryptography</topic>
      <topic importance='elective'> Perfect secrecy and the one time pad</topic>
      <topic importance='elective'> Modes of operation for semantic security and authenticated encryption (e.g.,  encrypt-then-MAC,  OCB, GCM)</topic>
      <topic importance='elective'> Message integrity (e.g., CMAC, HMAC)</topic>
      <topic importance='elective'> Public key cryptography:</topic>
      <topic importance='elective'> Trapdoor permutation, e.g., RSA</topic>
      <topic importance='elective'> Public key encryption, e.g., RSA encryption, EI Gamal encryption</topic>
      <topic importance='elective'> Digital signatures</topic>
      <topic importance='elective'> Public-key  infrastructure (PKI) and certificates</topic>
      <topic importance='elective'> Hardness assumptions, e.g.,  Diffie-Hellman,  integer factoring</topic>
      <topic importance='elective'> Authenticated key exchange protocols, e.g., TLS
      </topic>
      <topic importance='elective'> Cryptographic protocols:  challenge-response  authentication,  zero-knowledge  protocols, commitment, oblivious transfer, secure   or  multi-party  computation, secret sharing, and applications
      </topic>
      <topic importance='elective'> Motivate concepts using  real-world  applications, e.g., electronic cash, secure channels between clients and servers, secure electronic mail, entity authentication, device pairing, voting systems.
      </topic>
      <topic importance='elective'> Security definitions and attacks on cryptographic primitives:  </topic>
      <topic importance='elective'> Goals: indistinguishability, unforgeability,  collision-resistance</topic>
      <topic importance='elective'> Attacker capabilities:  chosen-message  attack (for signatures), birthday attacks, side channel attacks, fault injection attacks.</topic>
      <topic importance='elective'> Cryptographic standards and references implementations
      </topic>
      <topic importance='elective'> Quantum cryptography
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the purpose of cryptography and list ways it is used in data communications. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Define the following terms: cipher, cryptanalysis, cryptographic algorithm, and cryptology, and describe the two basic methods (ciphers) for transforming plain text in cipher text. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the importance of prime numbers in cryptography and explain their use in cryptographic algorithms. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how public key infrastructure supports digital signing and encryption and discuss the limitations/vulnerabilities. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use cryptographic primitives and describe their basic properties. </outcome>
      <outcome importance='elective' mastery_level='usage'>Illustrate how to measure entropy and how to generate cryptographic randomness. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use  public-key  primitives and their applications. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how key exchange protocols work and how they fail. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss cryptographic protocols and their properties. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe  real-world  applications of cryptographic primitives and protocols. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize security definitions related to attacks on cryptographic primitives, including attacker capabilities and goals.</outcome>
      <outcome importance='elective' mastery_level='usage'>Apply appropriate known cryptographic techniques for a given scenario. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Appreciate the dangers of inventing one’s own cryptographic methods. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe quantum cryptography and the impact of quantum computing on cryptographic algorithms. </outcome>
    </knowledgeArea>
    <knowledgeArea id='WS' name='Web Security'>
      <topic importance='elective'> Web security model</topic>
      <topic importance='elective'> Browser security model including  same-origin  policy</topic>
      <topic importance='elective'> Client-server  trust boundaries, e.g., cannot rely on secure execution in the client</topic>
      <topic importance='elective'> Session management, authentication</topic>
      <topic importance='elective'> Single  sign-on</topic>
      <topic importance='elective'> HTTPS and certificates</topic>
      <topic importance='elective'> Application vulnerabilities and defenses</topic>
      <topic importance='elective'> SQL injection</topic>
      <topic importance='elective'> XSS</topic>
      <topic importance='elective'> CSRF</topic>
      <topic importance='elective'> Client-side  security</topic>
      <topic importance='elective'> Cookies security policy</topic>
      <topic importance='elective'>HTTP security extensions, e.g. HSTS  o  Plugins, extensions, and web apps</topic>
      <topic importance='elective'>eb user tracking
      </topic>
      <topic importance='elective'> Server-side  security tools, e.g. Web Application Firewalls (WAFs) and fuzzers
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the browser security model including  same-origin  policy and threat models in web security. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concept of web sessions, secure communication channels such as TLS and importance of secure certificates, authentication including single  sign-on  such as OAuth and SAML. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe common types of vulnerabilities and attacks in web applications, and defenses against them. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use  client-side  security capabilities in an application. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PS' name='Platform Security'>
      <topic importance='elective'> Code integrity and code signing
      </topic>
      <topic importance='elective'> Secure boot, measured boot, and root of trust
      </topic>
      <topic importance='elective'> Attestation
      </topic>
      <topic importance='elective'> TPM and secure  co-processors
      </topic>
      <topic importance='elective'> Security threats from peripherals, e.g., DMA, IOMMU
      </topic>
      <topic importance='elective'> Physical attacks: hardware Trojans, memory probes, cold boot attacks
      </topic>
      <topic importance='elective'> Security of embedded devices, e.g., medical devices, cars
      </topic>
      <topic importance='elective'> Trusted path
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of code integrity and code signing and the scope it applies to. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concept of root of trust and the process of secure boot and secure loading. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the mechanism of remote attestation of system integrity. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize the goals and key primitives of TPM. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the threats of plugging peripherals into a device. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify physical attacks and countermeasures. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify attacks on  non-PC  hardware platforms. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the concept and importance of trusted path. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SPAG' name='Security Policy and Governance'>
      <topic importance='elective'> Privacy policy  (cross-reference  SP/Social Context/Social implications of computing in a networked world;  cross-reference  SP/Professional Ethics/Accountability, responsibility and liability;  cross-reference  SP/Privacy and Civil Liberties/Legal foundations of privacy protection)
      </topic>
      <topic importance='elective'> Inference controls/statistical disclosure limitation
      </topic>
      <topic importance='elective'> Backup policy, password refresh policy
      </topic>
      <topic importance='elective'> Breach disclosure policy
      </topic>
      <topic importance='elective'> Data collection and retention policies
      </topic>
      <topic importance='elective'> Supply chain policy
      </topic>
      <topic importance='elective'> Cloud security tradeoffs
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the concept of privacy including personally private information, potential violations of privacy due to security mechanisms, and describe how privacy protection mechanisms run in conflict with security mechanisms. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how an attacker can infer a secret by interacting with a database. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how to set a data backup policy or password refresh policy. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss how to set a breach disclosure policy. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the consequences of data retention policies. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the risks of relying on outsourced manufacturing. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the risks and benefits of outsourcing to the cloud. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DF' name='Digital Forensics'>
      <topic importance='elective'> Basic Principles and methodologies for digital forensics
      </topic>
      <topic importance='elective'> Design systems with forensic needs in mind
      </topic>
      <topic importance='elective'> Rules of Evidence – general concepts and differences between jurisdictions and Chain of Custody
      </topic>
      <topic importance='elective'> Search and Seizure of evidence: legal and procedural requirements
      </topic>
      <topic importance='elective'> Digital Evidence methods and standards
      </topic>
      <topic importance='elective'> Techniques and standards for Preservation of Data
      </topic>
      <topic importance='elective'> Legal and Reporting Issues including working as an expert witness
      </topic>
      <topic importance='elective'> OS/File System Forensics
      </topic>
      <topic importance='elective'> Application Forensics
      </topic>
      <topic importance='elective'> Web Forensics
      </topic>
      <topic importance='elective'> Network Forensics
      </topic>
      <topic importance='elective'> Mobile Device Forensics
      </topic>
      <topic importance='elective'> Computer/network/system attacks
      </topic>
      <topic importance='elective'> Attack detection and investigation
      </topic>
      <topic importance='elective'> Anti-forensics
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe what a digital investigation is, the sources of digital evidence, and the limitations of forensics. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how to design software to support forensics. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the legal requirements for use of seized data. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the process of evidence seizure from the time when the requirement was identified to the disposition of the data. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how data collection is accomplished and the proper storage of the original and forensics copy. </outcome>
      <outcome importance='elective' mastery_level='usage'>Conduct data collection on a hard drive. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe a person’s responsibility and liability while testifying as a forensics examiner. </outcome>
      <outcome importance='elective' mastery_level='usage'>Recover data based on a given search term from an imaged system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Reconstruct application history from application artifacts. </outcome>
      <outcome importance='elective' mastery_level='usage'>Reconstruct web browsing history from web artifacts. </outcome>
      <outcome importance='elective' mastery_level='usage'>Capture and interpret network traffic. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the challenges associated with mobile device forensics. </outcome>
      <outcome importance='elective' mastery_level='usage'>Inspect a system (network, computer, or application) for the presence of malware or malicious activity. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply forensics tools to investigate security breaches. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify  anti-forensic  methods. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SSE' name='Secure Software Engineering'>
      <topic importance='elective'> Building security into the software development lifecycle  (cross-reference  SE/Software Processes)
      </topic>
      <topic importance='elective'> Secure design principles and patterns
      </topic>
      <topic importance='elective'> Secure software specifications and requirements
      </topic>
      <topic importance='elective'> Secure software development practices  (cross-reference  SE/Software Construction)
      </topic>
      <topic importance='elective'> Secure testing - the process of testing that security requirements are met (including static and dynamic analysis).
      </topic>
      <topic importance='elective'> Software quality assurance and benchmarking measurements
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the requirements for integrating security into the software development lifecycle. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply the concepts of the Design Principles for Protection Mechanisms, the Principles for Software Security [2], and the Principles for Secure Design [1] on a software development project. </outcome>
      <outcome importance='elective' mastery_level='usage'>Develop specifications for a software development effort that fully specify functional requirements and identifies the expected execution paths. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe software development best practices for minimizing vulnerabilities in programming code. </outcome>
      <outcome importance='elective' mastery_level='usage'>Conduct a security verification and assessment (static and dynamic) of a software application. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='IM' name='Information Management'>
    <knowledgeArea id='IMC' name='Information Management Concepts'>
      <topic importance='tier1'> Information systems as  socio-technical  systems
      </topic>
      <topic importance='tier1'> Basic information storage and retrieval (IS&amp;R) concepts
      </topic>
      <topic importance='tier1'> Information capture and representation
      </topic>
      <topic importance='tier1'> Supporting human needs: searching, retrieving, linking, browsing, navigating
      </topic>
      <topic importance='tier2'> Information management applications
      </topic>
      <topic importance='tier2'> Declarative and navigational queries, use of links
      </topic>
      <topic importance='tier2'> Analysis and indexing
      </topic>
      <topic importance='tier2'> Quality issues: reliability, scalability, efficiency, and effectiveness
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how humans gain access to information and data to support their needs. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Describe the advantages and disadvantages of central organizational control over data. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify the careers/roles associated with information management (e.g., database administrator, data modeler, application developer,  end-user).  </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Compare and contrast information with data and knowledge. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Demonstrate uses of explicitly stored metadata/schema associated with data. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify issues of data persistence for an organization. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Critique an information application with regard to satisfying user information needs. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain uses of declarative queries. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Give a declarative version for a navigational query. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe several technical solutions to the problems related to information privacy, integrity, security, and preservation. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain measures of efficiency (throughput, response time) and effectiveness (recall, precision). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe approaches to scale up information systems. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify vulnerabilities and failure scenarios in common forms of information systems. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DS' name='Database Systems'>
      <topic importance='tier2'> Approaches to and evolution of database systems
      </topic>
      <topic importance='tier2'> Components of database systems
      </topic>
      <topic importance='tier2'> Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer management, access methods)
      </topic>
      <topic importance='tier2'> Database architecture and data independence
      </topic>
      <topic importance='tier2'> Use of a declarative query language
      </topic>
      <topic importance='tier2'> Systems supporting structured and/or stream content
      </topic>
      <topic importance='elective'> Approaches for managing large volumes of data (e.g., noSQL database systems, use of MapReduce).
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the characteristics that distinguish the database approach from the approach of programming with data files. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the most common designs for core database system components including the query optimizer, query executor, storage manager, access methods, and transaction processor. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Cite the basic goals, functions, and models of database systems. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the components of a database system and give examples of their use. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify major DBMS functions and describe their role in a database system. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the concept of data independence and its importance in a database system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use a declarative query language to elicit information from a database. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe facilities that datatbases provide supporting structures and/or stream (sequence) data, e.g., text. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe major approaches to storing and processing large volumes of data. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DM' name='Data Modeling'>
      <topic importance='tier2'> Data modeling
      </topic>
      <topic importance='tier2'> Conceptual models (e.g.,  entity-relationship,  UML diagrams)
      </topic>
      <topic importance='tier2'> Spreadsheet models
      </topic>
      <topic importance='tier2'> Relational data models
      </topic>
      <topic importance='tier2'> Object-oriented  models  (cross-reference   PL/Object-Oriented  Programming)
      </topic>
      <topic importance='tier2'> Semi-structured  data model (expressed using DTD or XML Schema, for example)
      </topic>
      <outcome importance='tier2' mastery_level='assessment'>Compare and contrast appropriate data models, including internal structures, for different types of data. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe concepts in modeling notation (e.g.,  Entity-Relation  Diagrams or UML) and how they would be used. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Define the fundamental terminology used in the relational data model. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the basic principles of the relational data model. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply the modeling concepts and notation of the relational data model. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the main concepts of the OO model such as object identity, type constructors, encapsulation, inheritance, polymorphism, and versioning. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Describe the differences between relational and  semi-structured  data models. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Give a  semi-structured  equivalent (e.g., in DTD or XML Schema) for a given relational schema. </outcome>
    </knowledgeArea>
    <knowledgeArea id='I' name='Indexing'>
      <topic importance='elective'> The impact of indices on query performance
      </topic>
      <topic importance='elective'> The basic structure of an index
      </topic>
      <topic importance='elective'> Keeping a buffer of data in memory
      </topic>
      <topic importance='elective'> Creating indexes with SQL
      </topic>
      <topic importance='elective'> Indexing text
      </topic>
      <topic importance='elective'> Indexing the web (e.g., web crawling)
      </topic>
      <outcome importance='elective' mastery_level='usage'>Generate an index file for a collection of resources. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the role of an inverted index in locating a document in a collection. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how stemming and stop words affect indexing. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify appropriate indices for given relational schema and query set. </outcome>
      <outcome importance='elective' mastery_level='usage'>Estimate time to retrieve information, when indices are used compared to when they are not used. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe key challenges in web crawling, e.g., detecting duplicate documents, determining the crawling frontier. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RD' name='Relational Databases'>
      <topic importance='elective'> Mapping conceptual schema to a relational schema
      </topic>
      <topic importance='elective'> Entity and referential integrity
      </topic>
      <topic importance='elective'> Relational algebra and relational calculus
      </topic>
      <topic importance='elective'> Relational Database design
      </topic>
      <topic importance='elective'> Functional dependency
      </topic>
      <topic importance='elective'> Decomposition of a schema;  lossless-join  and  dependency-preservation  properties of a decomposition
      </topic>
      <topic importance='elective'> Candidate keys, superkeys, and closure of a set of attributes
      </topic>
      <topic importance='elective'> Normal forms (BCNF)
      </topic>
      <topic importance='elective'> Multi-valued  dependency (4NF)
      </topic>
      <topic importance='elective'> Join dependency (PJNF, 5NF)
      </topic>
      <topic importance='elective'> Representation theory
      </topic>
      <outcome importance='elective' mastery_level='usage'>Prepare a relational schema from a conceptual model developed using the entity- relationship model. </outcome>
      <outcome importance='elective' mastery_level='usage'>Explain and demonstrate the concepts of entity integrity constraint and referential integrity constraint (including definition of the concept of a foreign key). </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate use of the relational algebra operations from mathematical set theory (union, intersection, difference, and Cartesian product) and the relational algebra operations developed specifically for relational databases (select (restrict), project, join, and division). </outcome>
      <outcome importance='elective' mastery_level='usage'>Write queries in the relational algebra. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write queries in the tuple relational calculus. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Determine the functional dependency between two or more attributes that are a subset of a relation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Connect constraints expressed as primary key and foreign key, with functional dependencies. </outcome>
      <outcome importance='elective' mastery_level='usage'>Compute the closure of a set of attributes under given functional dependencies. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Determine whether a set of attributes form a superkey and/or candidate key for a relation with given functional dependencies. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate a proposed decomposition, to say whether it has  lossless-join  and  dependency-preservation.  </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the properties of BCNF, PJNF, 5NF. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the impact of normalization on the efficiency of database operations especially query optimization. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe what is a  multi-valued  dependency and what type of constraints it specifies. </outcome>
    </knowledgeArea>
    <knowledgeArea id='QL' name='Query Languages'>
      <topic importance='elective'> Overview of database languages
      </topic>
      <topic importance='elective'> SQL (data definition, query formulation, update sublanguage, constraints, integrity)
      </topic>
      <topic importance='elective'> Selections
      </topic>
      <topic importance='elective'> Projections
      </topic>
      <topic importance='elective'> Select-project-join
      </topic>
      <topic importance='elective'> Aggregates  and   group-by
      </topic>
      <topic importance='elective'> Subqueries
      </topic>
      <topic importance='elective'> QBE and  4th-generation  environments
      </topic>
      <topic importance='elective'> Different ways to invoke  non-procedural  queries in conventional languages
      </topic>
      <topic importance='elective'> Introduction to other major query languages (e.g., XPATH, SPARQL)
      </topic>
      <topic importance='elective'> Stored procedures
      </topic>
      <outcome importance='elective' mastery_level='usage'>Create a relational database schema in SQL that incorporates key, entity integrity, and referential integrity constraints. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use SQL to create tables and retrieve (SELECT) information from a database. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate a set of query processing strategies and select the optimal strategy. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create a  non-procedural  query by filling in templates of relations to construct an example of the desired query result. </outcome>
      <outcome importance='elective' mastery_level='usage'>Embed  object-oriented  queries into a  stand-alone  language such as C++ or Java (e.g., SELECT Col.Method() FROM Object). </outcome>
      <outcome importance='elective' mastery_level='usage'>Write a stored procedure that deals with parameters and has some control flow, to provide a given functionality. </outcome>
    </knowledgeArea>
    <knowledgeArea id='TP' name='Transaction Processing'>
      <topic importance='elective'> Transactions
      </topic>
      <topic importance='elective'> Failure and recovery
      </topic>
      <topic importance='elective'> Concurrency control
      </topic>
      <topic importance='elective'> Interaction of transaction management with storage, especially buffering
      </topic>
      <outcome importance='elective' mastery_level='usage'>Create a transaction by embedding SQL into an application program. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of implicit commits. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the issues specific to efficient transaction execution. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Explain when and why rollback is needed and how logging assures proper rollback. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Explain the effect of different isolation levels on the concurrency control mechanisms. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Choose the proper isolation level for implementing a specified transaction protocol. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Identify appropriate transaction boundaries in application programs. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DD' name='Distributed Databases'>
      <topic importance='elective'> Distributed DBMS</topic>
      <topic importance='elective'> Distributed data storage</topic>
      <topic importance='elective'> Distributed query processing</topic>
      <topic importance='elective'> Distributed transaction model</topic>
      <topic importance='elective'> Homogeneous and heterogeneous solutions</topic>
      <topic importance='elective'> Client-server  distributed databases  (cross-reference  SF/Computational Paradigms)</topic>
      <topic importance='elective'> Parallel DBMS</topic>
      <topic importance='elective'> Parallel DBMS architectures: shared memory, shared disk, shared nothing;</topic>
      <topic importance='elective'> Speedup and  scale-up,  e.g., use of the MapReduce processing model  (cross-reference  CN/Processing, PD/Parallel Decomposition)</topic>
      <topic importance='elective'> Data replication and weak consistency models</topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the techniques used for data fragmentation, replication, and allocation during the distributed database design process. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate simple strategies for executing a distributed query to select the strategy that minimizes the amount of data transfer. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how the  two-phase  commit protocol is used to deal with committing a transaction that accesses databases stored on multiple nodes. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe distributed concurrency control based on the distinguished copy techniques and the voting method. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the three levels of software in the  client-server  model. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PDD' name='Physical Database Design'>
      <topic importance='elective'> Storage and file structure
      </topic>
      <topic importance='elective'> Indexed files
      </topic>
      <topic importance='elective'> Hashed files
      </topic>
      <topic importance='elective'> Signature files
      </topic>
      <topic importance='elective'> B-trees
      </topic>
      <topic importance='elective'> Files with dense index
      </topic>
      <topic importance='elective'> Files with variable length records
      </topic>
      <topic importance='elective'> Database efficiency and tuning
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concepts of records, record types, and files, as well as the different techniques for placing file records on disk. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Give examples of the application of primary, secondary, and clustering indexes. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Distinguish between a  non-dense  index and a dense index. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement dynamic multilevel indexes using  B-trees.  </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the theory and application of internal and external hashing techniques. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use hashing to facilitate dynamic file expansion. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the relationships among hashing, compression, and efficient database searches. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate costs and benefits of various hashing schemes. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how physical database design affects database transaction efficiency. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DM2' name='Data Mining'>
      <topic importance='elective'> Uses of data mining
      </topic>
      <topic importance='elective'> Data mining algorithms
      </topic>
      <topic importance='elective'> Associative and sequential patterns
      </topic>
      <topic importance='elective'> Data clustering
      </topic>
      <topic importance='elective'> Market basket analysis
      </topic>
      <topic importance='elective'> Data cleaning
      </topic>
      <topic importance='elective'> Data visualization  (cross-reference  GV/Visualization and CN/Interactive Visualization)
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast different uses of data mining as evidenced in both research and application. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the value of finding associations in market basket data. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Characterize the kinds of patterns that can be discovered by association rule mining. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how to extend a relational system to find patterns using association rules. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate different methodologies for effective application of data mining. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Identify and characterize sources of noise, redundancy, and outliers in presented data. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify mechanisms  (on-line  aggregation, anytime behavior, interactive visualization) to close the loop in the data mining process. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe why the various  close-the-loop  processes improve the effectiveness of data mining. </outcome>
    </knowledgeArea>
    <knowledgeArea id='ISAR' name='Information Storage and Retrieval'>
      <topic importance='elective'> Documents, electronic publishing, markup, and markup languages
      </topic>
      <topic importance='elective'> Tries, inverted files, PAT trees, signature files, indexing
      </topic>
      <topic importance='elective'> Morphological analysis, stemming, phrases, stop lists
      </topic>
      <topic importance='elective'> Term frequency distributions, uncertainty, fuzziness, weighting
      </topic>
      <topic importance='elective'> Vector space, probabilistic, logical, and advanced models
      </topic>
      <topic importance='elective'> Information needs, relevance, evaluation, effectiveness
      </topic>
      <topic importance='elective'> Thesauri, ontologies, classification and categorization, metadata
      </topic>
      <topic importance='elective'> Bibliographic information, bibliometrics, citations
      </topic>
      <topic importance='elective'> Routing and (community) filtering
      </topic>
      <topic importance='elective'> Multimedia search, information seeking behavior, user modeling, feedback
      </topic>
      <topic importance='elective'> Information summarization and visualization
      </topic>
      <topic importance='elective'> Faceted search (e.g., using citations, keywords, classification schemes)
      </topic>
      <topic importance='elective'> Digital libraries
      </topic>
      <topic importance='elective'> Digitization, storage, interchange, digital objects, composites, and packages
      </topic>
      <topic importance='elective'> Metadata and cataloging
      </topic>
      <topic importance='elective'> Naming, repositories, archives
      </topic>
      <topic importance='elective'> Archiving and preservation, integrity
      </topic>
      <topic importance='elective'> Spaces (conceptual, geographical, 2/3D, VR)
      </topic>
      <topic importance='elective'> Architectures (agents, buses, wrappers/mediators), interoperability
      </topic>
      <topic importance='elective'> Services (searching, linking, browsing, and so forth)
      </topic>
      <topic importance='elective'> Intellectual property rights management, privacy, and protection (watermarking)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain basic information storage and retrieval concepts. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe what issues are specific to efficient information retrieval. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Give applications of alternative search strategies and explain why the particular search strategy is appropriate for the application. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement a small to medium size information storage and retrieval system, or digital library. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe some of the technical solutions to the problems related to archiving and preserving information in a digital library. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MS' name='Multimedia Systems'>
      <topic importance='elective'> Input and output devices, device drivers, control signals and protocols, DSPs
      </topic>
      <topic importance='elective'> Standards (e.g., audio, graphics, video)
      </topic>
      <topic importance='elective'> Applications, media editors, authoring systems, and authoring
      </topic>
      <topic importance='elective'> Streams/structures, capture/represent/transform, spaces/domains, compression/coding
      </topic>
      <topic importance='elective'> Content-based  analysis, indexing, and retrieval of audio, images, animation, and video
      </topic>
      <topic importance='elective'> Presentation, rendering, synchronization,  multi-modal  integration/interfaces
      </topic>
      <topic importance='elective'> Real-time  delivery, quality of service (including performance), capacity planning, audio/video conferencing,  video-on-demand
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the media and supporting devices commonly associated with multimedia information and systems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate the use of  content-based  information analysis in a multimedia information system. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Critique multimedia presentations in terms of their appropriate use of audio, video, graphics, color, and other information presentation concepts. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a multimedia application using an authoring system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>For each of several media or multimedia standards, describe in  non-technical  language what the standard calls for, and explain how aspects of human perception might be sensitive to the limitations of that standard. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the characteristics of a computer system (including identification of support tools and appropriate standards) that has to host the implementation of one of a range of possible multimedia applications. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='IS' name='Intelligent Systems'>
    <knowledgeArea id='FI' name='Fundamental Issues'>
      <topic importance='tier2'> Overview of AI problems, examples of successful recent AI applications
      </topic>
      <topic importance='tier2'> What is intelligent behavior?</topic>
      <topic importance='tier2'> The Turing test</topic>
      <topic importance='tier2'> Rational versus  non-rational  reasoning</topic>
      <topic importance='tier2'> Problem characteristics</topic>
      <topic importance='tier2'> Fully versus partially observable</topic>
      <topic importance='tier2'> Single versus  multi-agent</topic>
      <topic importance='tier2'> Deterministic versus stochastic</topic>
      <topic importance='tier2'> Static versus dynamic</topic>
      <topic importance='tier2'> Discrete versus continuous</topic>
      <topic importance='tier2'> Nature of agents</topic>
      <topic importance='tier2'> Autonomous versus  semi-autonomous</topic>
      <topic importance='tier2'> Reflexive,  goal-based,  and  utility-based</topic>
      <topic importance='tier2'> The importance of perception and environmental interactions</topic>
      <topic importance='tier2'> Philosophical and ethical issues. [elective]
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe Turing test and the “Chinese Room” thought experiment. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Differentiate between the concepts of optimal reasoning/behavior and  human-like  reasoning/behavior. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Determine the characteristics of a given problem that an intelligent system must solve. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BSS' name='Basic Search Strategies'>
      <topic importance='tier2'> Problem spaces (states, goals and operators), problem solving by search
      </topic>
      <topic importance='tier2'> Factored representation (factoring state into variables)
      </topic>
      <topic importance='tier2'> Uninformed search  (breadth-first,   depth-first,   depth-first  with iterative deepening)
      </topic>
      <topic importance='tier2'> Heuristics and informed search  (hill-climbing,  generic  best-first,  A*)
      </topic>
      <topic importance='tier2'> Space and time efficiency of search
      </topic>
      <topic importance='tier2'> Two-player  games (introduction to minimax search)
      </topic>
      <topic importance='tier2'> Constraint satisfaction (backtracking and local search methods)
      </topic>
      <outcome importance='tier2' mastery_level='usage'>Formulate an efficient problem space for a problem expressed in natural language (e.g., English) in terms of initial and goal states, and operators. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the role of heuristics and describe the  trade-offs  among completeness, optimality, time complexity, and space complexity. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the problem of combinatorial explosion of search space and its consequences. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Select and implement an appropriate uninformed search algorithm for a problem, and characterize its time and space complexities. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Select and implement an appropriate informed search algorithm for a problem by designing the necessary heuristic evaluation function. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Evaluate whether a heuristic for a given problem is admissible/can guarantee optimal solution. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Formulate a problem specified in natural language (e.g., English) as a constraint satisfaction problem and implement it using a chronological backtracking algorithm or stochastic local search. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Compare and contrast basic search issues with game playing issues. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BKRAR' name='Basic Knowledge Representation and Reasoning'>
      <topic importance='tier2'> Review of propositional and predicate logic  (cross-reference  DS/Basic Logic)
      </topic>
      <topic importance='tier2'> Resolution and theorem proving (propositional logic only)
      </topic>
      <topic importance='tier2'> Forward chaining, backward chaining
      </topic>
      <topic importance='tier2'> Review of probabilistic reasoning, Bayes theorem  (cross-reference  with DS/Discrete Probability)
      </topic>
      <outcome importance='tier2' mastery_level='usage'>Translate a natural language (e.g., English) sentence into predicate logic statement. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Convert a logic statement into clause form. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply resolution to a set of logic statements to answer a query. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Make a probabilistic inference in a  real-world  problem using Bayes’ theorem to determine the probability of a hypothesis given evidence. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BML' name='Basic Machine Learning'>
      <topic importance='tier2'> Definition and examples of broad variety of machine learning tasks, including classification
      </topic>
      <topic importance='tier2'> Inductive learning
      </topic>
      <topic importance='tier2'> Simple  statistical-based  learning, such as Naive Bayesian Classifier, decision trees
      </topic>
      <topic importance='tier2'> The  over-fitting  problem
      </topic>
      <topic importance='tier2'> Measuring classifier accuracy
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>List the differences among the three main styles of learning: supervised, reinforcement, and unsupervised. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify examples of classification tasks, including the available input features and output to be predicted. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the difference between inductive and deductive learning. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe  over-fitting  in the context of a problem. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply the simple statistical learning algorithm such as Naive Bayesian Classifier to a classification task and measure the classifier's accuracy. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AS' name='Advanced Search'>
      <topic importance='elective'> Constructing search trees, dynamic search space, combinatorial explosion of search space
      </topic>
      <topic importance='elective'> Stochastic search</topic>
      <topic importance='elective'>Simulated annealing</topic>
      <topic importance='elective'>enetic algorithms</topic>
      <topic importance='elective'>  Monte-Carlo  tree search</topic>
      <topic importance='elective'> Implementation of A* search, beam search
      </topic>
      <topic importance='elective'> Minimax search,  alpha-beta  pruning
      </topic>
      <topic importance='elective'> Expectimax search  (MDP-solving)  and chance nodes
      </topic>
      <outcome importance='elective' mastery_level='usage'>Design and implement a genetic algorithm solution to a problem. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement a simulated annealing schedule to avoid local minima in a problem. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement A*/beam search to solve a problem. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply minimax search with  alpha-beta  pruning to prune search space in a  two-player  game. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast genetic algorithms with classic search techniques. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast various heuristic searches  vis-a-vis  applicability to a given problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='ARAR' name='Advanced Representation and Reasoning'>
      <topic importance='elective'>Knowledge representation issues
      </topic>
      <topic importance='elective'>escription logics</topic>
      <topic importance='elective'>  Ontology engineering</topic>
      <topic importance='elective'> Non-monotonic  reasoning (e.g.,  non-classical  logics, default reasoning)
      </topic>
      <topic importance='elective'> Argumentation
      </topic>
      <topic importance='elective'> Reasoning about action and change (e.g., situation and event calculus)
      </topic>
      <topic importance='elective'> Temporal and spatial reasoning
      </topic>
      <topic importance='elective'> Rule-based  Expert Systems
      </topic>
      <topic importance='elective'> Semantic networks
      </topic>
      <topic importance='elective'> Model-based  and  Case-based  reasoning
      </topic>
      <topic importance='elective'> Planning:</topic>
      <topic importance='elective'>Partial and totally ordered planning</topic>
      <topic importance='elective'>lan graphs</topic>
      <topic importance='elective'>  Hierarchical planning</topic>
      <topic importance='elective'>Planning and execution including conditional planning and continuous planning</topic>
      <topic importance='elective'>obile  agent/Multi-agent  planning
      </topic>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast the most common models used for structured knowledge representation, highlighting their strengths and weaknesses. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the components of  non-monotonic  reasoning and its usefulness as a representational mechanism for belief systems. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast the basic techniques for representing uncertainty. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast the basic techniques for qualitative representation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply situation and event calculus to problems of action and change. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the distinction between temporal and spatial reasoning, and how they interrelate. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the difference between  rule-based,   case-based  and  model-based  reasoning techniques. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Define the concept of a planning system and how it differs from classical search techniques. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the differences between planning as search,  operator-based  planning, and propositional planning, providing examples of domains where each is most applicable. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the distinction between monotonic and  non-monotonic  inference. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RUU' name='Reasoning Under Uncertainty'>
      <topic importance='elective'> Review of basic probability  (cross-reference  DS/Discrete Probability)
      </topic>
      <topic importance='elective'> Random variables and probability distributions</topic>
      <topic importance='elective'> Axioms of probability</topic>
      <topic importance='elective'> Probabilistic inference</topic>
      <topic importance='elective'> Bayes’ Rule</topic>
      <topic importance='elective'> Conditional Independence
      </topic>
      <topic importance='elective'> Knowledge representations</topic>
      <topic importance='elective'> Bayesian Networks</topic>
      <topic importance='elective'> Markov Networks</topic>
      <topic importance='elective'> Relational probability models</topic>
      <topic importance='elective'> Hidden Markov Models</topic>
      <topic importance='elective'> Decision Theory</topic>
      <topic importance='elective'> Preferences and utility functions</topic>
      <topic importance='elective'> Maximizing expected utility</topic>
      <outcome importance='elective' mastery_level='usage'>Apply Bayes’ rule to determine the probability of a hypothesis given evidence. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Explain how conditional independence assertions allow for greater efficiency of probabilistic systems. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify examples of knowledge representations for reasoning under uncertainty. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>State the complexity of exact inference. Identify methods for approximate inference. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement at least one knowledge representation for reasoning under uncertainty. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the complexities of temporal probabilistic reasoning. </outcome>
      <outcome importance='elective' mastery_level='usage'>Design and implement an HMM as one example of a temporal probabilistic system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the relationship between preferences and utility functions. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Explain how utility functions and probabilistic reasoning can be combined to make rational decisions. </outcome>
    </knowledgeArea>
    <knowledgeArea id='A' name='Agents'>
      <topic importance='elective'> Definitions of agents
      </topic>
      <topic importance='elective'> Agent architectures (e.g., reactive, layered, cognitive)
      </topic>
      <topic importance='elective'> Agent theory
      </topic>
      <topic importance='elective'> Rationality, game theory</topic>
      <topic importance='elective'> Decision-theoretic  agents</topic>
      <topic importance='elective'> Markov decision processes (MDP)</topic>
      <topic importance='elective'> Software agents, personal assistants, and information access</topic>
      <topic importance='elective'> Collaborative agents</topic>
      <topic importance='elective'> Information-gathering  agents</topic>
      <topic importance='elective'> Believable agents (synthetic characters, modeling emotions in agents)</topic>
      <topic importance='elective'> Learning agents
      </topic>
      <topic importance='elective'> Multi-agent  systems</topic>
      <topic importance='elective'> Collaborating agents</topic>
      <topic importance='elective'> Agent teams</topic>
      <topic importance='elective'> Competitive agents (e.g., auctions, voting)</topic>
      <topic importance='elective'> Swarm systems and biologically inspired models</topic>
      <outcome importance='elective' mastery_level='familiarity'>List the defining characteristics of an intelligent agent. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Characterize and contrast the standard agent architectures. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the applications of agent theory to domains such as software agents, personal assistants, and believable agents. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the primary paradigms used by learning agents. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate using appropriate examples how  multi-agent  systems support agent interaction. </outcome>
    </knowledgeArea>
    <knowledgeArea id='NLP' name='Natural Language Processing'>
      <topic importance='elective'> Deterministic and stochastic grammars
      </topic>
      <topic importance='elective'> Parsing algorithms</topic>
      <topic importance='elective'> CFGs and chart parsers (e.g. CYK)</topic>
      <topic importance='elective'> Probabilistic CFGs and weighted CYK</topic>
      <topic importance='elective'> Representing meaning / Semantics</topic>
      <topic importance='elective'> Logic-based  knowledge representations</topic>
      <topic importance='elective'> Semantic roles</topic>
      <topic importance='elective'> Temporal representations</topic>
      <topic importance='elective'> Beliefs, desires, and intentions</topic>
      <topic importance='elective'> Corpus-based  methods
      </topic>
      <topic importance='elective'> N-grams  and HMMs
      </topic>
      <topic importance='elective'> Smoothing and backoff
      </topic>
      <topic importance='elective'> Examples of use: POS tagging and morphology
      </topic>
      <topic importance='elective'> Information retrieval  (Cross-reference  IM/Information Storage and Retrieval)</topic>
      <topic importance='elective'> Vector space model</topic>
      <topic importance='elective'> Precision and recall</topic>
      <topic importance='elective'> Information extraction
      </topic>
      <topic importance='elective'> Language translation
      </topic>
      <topic importance='elective'> Text classification, categorization</topic>
      <topic importance='elective'> Bag of words model</topic>
      <outcome importance='elective' mastery_level='assessment'>Define and contrast deterministic and stochastic grammars, providing examples to show the adequacy of each. </outcome>
      <outcome importance='elective' mastery_level='usage'>Simulate, apply, or implement classic and stochastic algorithms for parsing natural language. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the challenges of representing meaning. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List the advantages of using standard corpora. Identify examples of current corpora for a variety of NLP tasks. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify techniques for information retrieval, language translation, and text classification. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AML' name='Advanced Machine Learning'>
      <topic importance='elective'> Definition and examples of broad variety of machine learning tasks
      </topic>
      <topic importance='elective'> General  statistical-based  learning, parameter estimation (maximum likelihood)
      </topic>
      <topic importance='elective'> Inductive logic programming (ILP)
      </topic>
      <topic importance='elective'> Supervised learning</topic>
      <topic importance='elective'> Learning decision trees</topic>
      <topic importance='elective'> Learning neural networks</topic>
      <topic importance='elective'> Support vector machines (SVMs)</topic>
      <topic importance='elective'> Ensembles
      </topic>
      <topic importance='elective'> Nearest-neighbor  algorithms
      </topic>
      <topic importance='elective'> Unsupervised Learning and clustering</topic>
      <topic importance='elective'> EM</topic>
      <topic importance='elective'> K-means</topic>
      <topic importance='elective'> Self-organizing  maps</topic>
      <topic importance='elective'> Semi-supervised  learning
      </topic>
      <topic importance='elective'> Learning graphical models  (Cross-reference  IS/Reasoning under Uncertainty)
      </topic>
      <topic importance='elective'> Performance evaluation (such as  cross-validation,  area under ROC curve)
      </topic>
      <topic importance='elective'> Learning theory
      </topic>
      <topic importance='elective'> The problem of overfitting, the curse of dimensionality
      </topic>
      <topic importance='elective'> Reinforcement learning</topic>
      <topic importance='elective'> Exploration vs. exploitation  trade-off</topic>
      <topic importance='elective'>Markov decision processes</topic>
      <topic importance='elective'>alue and policy iteration
      </topic>
      <topic importance='elective'> Application of Machine Learning algorithms to Data Mining  (cross-reference  IM/Data Mining)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the differences among the three main styles of learning: supervised, reinforcement, and unsupervised. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement simple algorithms for supervised learning, reinforcement learning, and unsupervised learning. </outcome>
      <outcome importance='elective' mastery_level='usage'>Determine which of the three learning styles is appropriate to a particular problem domain. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast each of the following techniques, providing examples of when each strategy is superior: decision trees, neural networks, and belief networks. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate the performance of a simple learning system on a  real-world  dataset. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Characterize the state of the art in learning theory, including its achievements and its shortcomings. </outcome>
      <outcome importance='elective' mastery_level='usage'>Explain the problem of overfitting, along with techniques for detecting and managing the problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='R' name='Robotics'>
      <topic importance='elective'> Overview: problems and progress</topic>
      <topic importance='elective'>State-of-the-art  robot systems, including their sensors and an overview of their sensor processing</topic>
      <topic importance='elective'>obot control architectures, e.g., deliberative vs. reactive control and Braitenberg vehicles</topic>
      <topic importance='elective'>  World modeling and world models</topic>
      <topic importance='elective'>  Inherent uncertainty in sensing and in control</topic>
      <topic importance='elective'> Configuration space and environmental maps
      </topic>
      <topic importance='elective'> Interpreting uncertain sensor data
      </topic>
      <topic importance='elective'> Localizing and mapping
      </topic>
      <topic importance='elective'> Navigation and control
      </topic>
      <topic importance='elective'> Motion planning
      </topic>
      <topic importance='elective'> Multiple-robot  coordination
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>List capabilities and limitations of today's  state-of-the-art  robot systems, including their sensors and the crucial sensor processing that informs those systems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Integrate sensors, actuators, and software into a robot designed to undertake some task. </outcome>
      <outcome importance='elective' mastery_level='usage'>Program a robot to accomplish simple tasks using deliberative, reactive, and/or hybrid control architectures. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement fundamental motion planning algorithms within a robot configuration space. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Characterize the uncertainties associated with common robot sensors and actuators; articulate strategies for mitigating these uncertainties. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List the differences among robots' representations of their external environment, including their strengths and shortcomings. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast at least three strategies for robot navigation within known and/or unknown environments, including their strengths and shortcomings. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe at least one approach for coordinating the actions and sensing of several robots to accomplish a single task. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PACV' name='Perception and Computer Vision'>
      <topic importance='elective'> Computer vision</topic>
      <topic importance='elective'> Image acquisition, representation, processing and properties</topic>
      <topic importance='elective'> Shape representation, object recognition and segmentation</topic>
      <topic importance='elective'> Motion analysis</topic>
      <topic importance='elective'> Audio and speech recognition
      </topic>
      <topic importance='elective'> Modularity in recognition
      </topic>
      <topic importance='elective'> Approaches to pattern recognition  (cross-reference  IS/Advanced Machine Learning)</topic>
      <topic importance='elective'> Classification algorithms and measures of classification quality</topic>
      <topic> Statistical techniques</topic>
      <outcome importance='elective' mastery_level='familiarity'>Summarize the importance of image and object recognition in AI and indicate several significant applications of this technology. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List at least three  image-segmentation  approaches, such as thresholding,  edge-based  and  region-based  algorithms, along with their defining characteristics, strengths, and weaknesses. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement 2d object recognition based on contour- and/or  region-based  shape representations. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Distinguish the goals of  sound-recognition,   speech-recognition,  and  speaker-recognition  and identify how the raw audio signal will be handled differently in each of these cases. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Provide at least two examples of a transformation of a data source from one sensory domain to another, e.g., tactile data interpreted as  single-band  2d images. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a  feature-extraction  algorithm on real data, e.g., an edge or corner detector for images or vectors of Fourier coefficients describing a short slice of audio signal. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement an algorithm combining features into  higher-level  percepts, e.g., a contour or polygon from visual primitives or phoneme hypotheses from an audio signal. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a classification algorithm that segments input percepts into output categories and quantitatively evaluates the resulting classification. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate the performance of the underlying  feature-extraction,  relative to at least one alternative possible approach (whether implemented or not) in its contribution to the classification task (8), above. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe at least three classification approaches, their prerequisites for applicability, their strengths, and their shortcomings. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='NC' name='Networking and Communications'>
    <knowledgeArea id='I' name='Introduction'>
      <topic importance='tier1'> Organization of the Internet (Internet Service Providers, Content Providers, etc.)
      </topic>
      <topic importance='tier1'> Switching techniques (e.g., circuit, packet)
      </topic>
      <topic importance='tier1'> Physical pieces of a network, including hosts, routers, switches, ISPs, wireless, LAN, access point, and firewalls
      </topic>
      <topic importance='tier1'> Layering principles (encapsulation, multiplexing)
      </topic>
      <topic importance='tier1'> Roles of the different layers (application, transport, network, datalink, physical)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Articulate the organization of the Internet. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>List and define the appropriate network terminology. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the layered structure of a typical networked architecture. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify the different types of complexity in a network (edges, core, etc.). </outcome>
    </knowledgeArea>
    <knowledgeArea id='NA' name='Networked Applications'>
      <topic importance='tier1'> Naming and address schemes (DNS, IP addresses, Uniform Resource Identifiers, etc.)
      </topic>
      <topic importance='tier1'> Distributed applications (client/server,  peer-to-peer,  cloud, etc.)
      </topic>
      <topic importance='tier1'> HTTP as an application layer protocol
      </topic>
      <topic importance='tier1'> Multiplexing with TCP and UDP
      </topic>
      <topic importance='tier1'> Socket APIs
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>List the differences and the relations between names and addresses in a network. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Define the principles behind naming schemes and resource location. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Implement a simple  client-server   socket-based  application. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RDD' name='Reliable Data Delivery'>
      <topic importance='tier2'> Error control (retransmission techniques, timers)
      </topic>
      <topic importance='tier2'> Flow control (acknowledgements, sliding window)
      </topic>
      <topic importance='tier2'> Performance issues (pipelining)
      </topic>
      <topic importance='tier2'> TCP
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the operation of reliable delivery protocols. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>List the factors that affect the performance of reliable delivery protocols. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Design and implement a simple reliable protocol. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RAF' name='Routing and Forwarding'>
      <topic importance='tier2'> Routing versus forwarding
      </topic>
      <topic importance='tier2'> Static routing
      </topic>
      <topic importance='tier2'> Internet Protocol (IP)
      </topic>
      <topic importance='tier2'> Scalability issues (hierarchical addressing)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the organization of the network layer. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how packets are forwarded in an IP network. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>List the scalability benefits of hierarchical addressing. </outcome>
    </knowledgeArea>
    <knowledgeArea id='LAN' name='Local Area Networks'>
      <topic importance='tier2'> Multiple Access Problem
      </topic>
      <topic importance='tier2'> Common approaches to multiple access  (exponential-backoff,  time division multiplexing, etc)
      </topic>
      <topic importance='tier2'> Local Area Networks
      </topic>
      <topic importance='tier2'> Ethernet
      </topic>
      <topic importance='tier2'> Switching
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how frames are forwarded in an Ethernet network. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the differences between IP and Ethernet. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the interrelations between IP and Ethernet. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the steps used in one common approach to the multiple access problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RA' name='Resource Allocation'>
      <topic importance='tier2'> Need for resource allocation
      </topic>
      <topic importance='tier2'> Fixed allocation (TDM, FDM, WDM) versus dynamic allocation
      </topic>
      <topic importance='tier2'> End-to-end  versus network assisted approaches
      </topic>
      <topic importance='tier2'> Fairness
      </topic>
      <topic importance='tier2'> Principles of congestion control
      </topic>
      <topic importance='tier2'> Approaches to Congestion (e.g., Content Distribution Networks)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how resources can be allocated in a network. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the congestion problem in a large network. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Compare and contrast fixed and dynamic allocation techniques. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Compare and contrast current approaches to congestion. </outcome>
    </knowledgeArea>
    <knowledgeArea id='M' name='Mobility'>
      <topic importance='tier2'> Principles of cellular networks
      </topic>
      <topic importance='tier2'> 802.11 networks
      </topic>
      <topic importance='tier2'> Issues in supporting mobile nodes (home agents)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the organization of a wireless network. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how wireless networks support mobile users. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SN' name='Social Networking'>
      <topic importance='elective'> Social networks overview
      </topic>
      <topic importance='elective'> Example social network platforms
      </topic>
      <topic importance='elective'> Structure of social network graphs
      </topic>
      <topic importance='elective'> Social network analysis
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the key principles (such as membership, trust) of social networking. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how existing social networks operate. </outcome>
      <outcome importance='elective' mastery_level='usage'>Construct a social network graph from network data. </outcome>
      <outcome importance='elective' mastery_level='usage'>Analyze a social network to determine who the key people are. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate a given interpretation of a social network question with associated data. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='OS' name='Operating Systems'>
    <knowledgeArea id='OOOS' name='Overview of Operating Systems'>
      <topic importance='tier1'> Role and purpose of the operating system
      </topic>
      <topic importance='tier1'> Functionality of a typical operating system
      </topic>
      <topic importance='tier1'> Mechanisms to support  client-server  models,  hand-held  devices
      </topic>
      <topic importance='tier1'> Design issues (efficiency, robustness, flexibility, portability, security, compatibility)
      </topic>
      <topic importance='tier1'> Influences of security, networking, multimedia, windowing systems
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the objectives and functions of modern operating systems. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Analyze the tradeoffs inherent in operating system design. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the functions of a contemporary operating system with respect to convenience, efficiency, and the ability to evolve. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss networked,  client-server,  distributed operating systems and how they differ from single user operating systems. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify potential threats to operating systems and the security features design to guard against them. </outcome>
    </knowledgeArea>
    <knowledgeArea id='OSP' name='Operating System Principles'>
      <topic importance='tier1'> Structuring methods (monolithic, layered, modular,  micro-kernel  models)
      </topic>
      <topic importance='tier1'> Abstractions, processes, and resources
      </topic>
      <topic importance='tier1'> Concepts of application program interfaces (APIs)
      </topic>
      <topic importance='tier1'> The evolution of hardware/software techniques and application needs
      </topic>
      <topic importance='tier1'> Device organization
      </topic>
      <topic importance='tier1'> Interrupts: methods and implementations
      </topic>
      <topic importance='tier1'> Concept of user/system state and protection, transition to kernel mode
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the concept of a logical layer. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the benefits of building abstract layers in hierarchical fashion. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Describe the value of APIs and middleware. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how computing resources are used by application software and managed by system software. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Contrast kernel and user mode in an operating system. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the advantages and disadvantages of using interrupt processing. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the use of a device list and driver I/O queue. </outcome>
    </knowledgeArea>
    <knowledgeArea id='C' name='Concurrency'>
      <topic importance='tier2'> States and state diagrams  (cross-reference  SF/State and State Machines)
      </topic>
      <topic importance='tier2'> Structures (ready list, process control blocks, and so forth)
      </topic>
      <topic importance='tier2'> Dispatching and context switching
      </topic>
      <topic importance='tier2'> The role of interrupts
      </topic>
      <topic importance='tier2'> Managing atomic access to OS objects
      </topic>
      <topic importance='tier2'> Implementing synchronization primitives
      </topic>
      <topic importance='tier2'> Multiprocessor issues  (spin-locks,  reentrancy)  (cross-reference  SF/Parallelism)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the need for concurrency within the framework of an operating system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Demonstrate the potential  run-time  problems arising from the concurrent operation of many separate tasks. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Summarize the range of mechanisms that can be employed at the operating system level to realize concurrent systems and describe the benefits of each. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the different states that a task may pass through and the data structures needed to support the management of many tasks. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Summarize techniques for achieving synchronization in an operating system (e.g., describe how to implement a semaphore using OS primitives). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe reasons for using interrupts, dispatching, and context switching to support concurrency in an operating system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Create state and transition diagrams for simple problem domains. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SAD' name='Scheduling and Dispatch'>
      <topic importance='tier2'> Preemptive and  non-preemptive  scheduling  (cross-reference  SF/Resource Allocation and Scheduling, PD/Parallel Performance)
      </topic>
      <topic importance='tier2'> Schedulers and policies  (cross-reference  SF/Resource Allocation and Scheduling, PD/Parallel Performance)
      </topic>
      <topic importance='tier2'> Processes and threads  (cross-reference  SF/Computational paradigms)
      </topic>
      <topic importance='tier2'> Deadlines and  real-time  issues
      </topic>
      <outcome importance='tier2' mastery_level='usage'>Compare and contrast the common algorithms used for both preemptive and  non-preemptive  scheduling of tasks in operating systems, such as priority, performance comparison, and  fair-share  schemes. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe relationships between scheduling algorithms and application domains. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the types of processor scheduling such as  short-term,   medium-term,   long-term,  and I/O. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Describe the difference between processes and threads. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Compare and contrast static and dynamic approaches to  real-time  scheduling. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the need for preemption and deadline scheduling. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify ways that the logic embodied in scheduling algorithms are applicable to other domains, such as disk I/O, network scheduling, project scheduling, and problems beyond computing. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MM' name='Memory Management'>
      <topic importance='tier2'> Review of physical memory and memory management hardware
      </topic>
      <topic importance='tier2'> Working sets and thrashing
      </topic>
      <topic importance='tier2'> Caching  (cross-reference  AR/Memory System Organization and Architecture)
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain memory hierarchy and  cost-performance   trade-offs.  </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Summarize the principles of virtual memory as applied to caching and paging. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Evaluate the  trade-offs  in terms of memory size (main memory, cache memory, auxiliary memory) and processor speed. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Defend the different ways of allocating memory to tasks, citing the relative merits of each. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the reason for and use of cache memory (performance and proximity, different dimension of how caches complicate isolation and VM abstraction). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the concept of thrashing, both in terms of the reasons it occurs and the techniques used to recognize and manage the problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SAP' name='Security and Protection'>
      <topic importance='tier2'> Overview of system security
      </topic>
      <topic importance='tier2'> Policy/mechanism separation
      </topic>
      <topic importance='tier2'> Security methods and devices
      </topic>
      <topic importance='tier2'> Protection, access control, and authentication
      </topic>
      <topic importance='tier2'> Backups
      </topic>
      <outcome importance='tier2' mastery_level='assessment'>Articulate the need for protection and security in an OS  (cross-reference  IAS/Security Architecture and Systems Administration/Investigating Operating Systems Security for various systems). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Summarize the features and limitations of an operating system used to provide protection and security  (cross-reference  IAS/Security Architecture and Systems Administration). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the mechanisms available in an OS to control access to resources  (cross-reference  IAS/Security Architecture and Systems Administration/Access Control/Configuring systems to operate securely as an IT system). </outcome>
      <outcome importance='tier2' mastery_level='usage'>Carry out simple system administration tasks according to a security policy, for example creating accounts, setting permissions, applying patches, and arranging for regular backups  (cross-reference  IAS/Security Architecture and Systems Administration). </outcome>
    </knowledgeArea>
    <knowledgeArea id='VM' name='Virtual Machines'>
      <topic importance='elective'> Types of virtualization (including Hardware/Software, OS, Server, Service, Network)
      </topic>
      <topic importance='elective'> Paging and virtual memory
      </topic>
      <topic importance='elective'> Virtual file systems
      </topic>
      <topic importance='elective'> Hypervisors
      </topic>
      <topic importance='elective'> Portable virtualization; emulation vs. isolation
      </topic>
      <topic importance='elective'> Cost of virtualization
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the concept of virtual memory and how it is realized in hardware and software. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Differentiate emulation and isolation. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate virtualization  trade-offs.  </outcome>
      <outcome importance='elective' mastery_level='usage'>Discuss hypervisors and the need for them in conjunction with different types of hypervisors. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DM' name='Device Management'>
      <topic importance='elective'> Characteristics of serial and parallel devices
      </topic>
      <topic importance='elective'> Abstracting device differences
      </topic>
      <topic importance='elective'> Buffering strategies
      </topic>
      <topic importance='elective'> Direct memory access
      </topic>
      <topic importance='elective'> Recovery from failures
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the key difference between serial and parallel devices and identify the conditions in which each is appropriate. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify the relationship between the physical hardware and the virtual devices maintained by the operating system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain buffering and describe strategies for implementing it. </outcome>
      <outcome importance='elective' mastery_level='usage'>Differentiate the mechanisms used in interfacing a range of devices (including  hand-held  devices, networks, multimedia) to a computer and explain the implications of these for the design of an operating system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Describe the advantages and disadvantages of direct memory access and discuss the circumstances in which its use is warranted. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the requirements for failure recovery. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a simple device driver for a range of possible devices. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FS' name='File Systems'>
      <topic importance='elective'> Files: data, metadata, operations, organization, buffering, sequential, nonsequential
      </topic>
      <topic importance='elective'> Directories: contents and structure
      </topic>
      <topic importance='elective'> File systems: partitioning, mount/unmount, virtual file systems
      </topic>
      <topic importance='elective'> Standard implementation techniques
      </topic>
      <topic importance='elective'> Memory-mapped  files
      </topic>
      <topic importance='elective'> Special-purpose  file systems
      </topic>
      <topic importance='elective'> Naming, searching, access, backups
      </topic>
      <topic importance='elective'> Journaling and  log-structured  file systems
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the choices to be made in designing file systems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Compare and contrast different approaches to file organization, recognizing the strengths and weaknesses of each. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize how hardware developments have led to changes in the priorities for the design and the management of file systems. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize the use of journaling and how  log-structured  file systems enhance fault tolerance. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RTAES' name='Real Time and Embedded Systems'>
      <topic importance='elective'> Process and task scheduling
      </topic>
      <topic importance='elective'> Memory/disk management requirements in a  real-time  environment
      </topic>
      <topic importance='elective'> Failures, risks, and recovery
      </topic>
      <topic importance='elective'> Special concerns in  real-time  systems
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe what makes a system a  real-time  system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the presence of and describe the characteristics of latency in  real-time  systems. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Summarize special concerns that  real-time  systems present, including risk, and how these concerns are addressed. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FT' name='Fault Tolerance'>
      <topic importance='elective'> Fundamental concepts: reliable and available systems  (cross-reference  SF/Reliability through Redundancy)
      </topic>
      <topic importance='elective'> Spatial and temporal redundancy  (cross-reference  SF/Reliability through Redundancy)
      </topic>
      <topic importance='elective'> Methods used to implement fault tolerance
      </topic>
      <topic importance='elective'> Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of these techniques for the OS’s own services
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the relevance of the terms fault tolerance, reliability, and availability. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Outline the range of methods for implementing fault tolerance in an operating system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how an operating system can continue functioning after a fault occurs. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SPE' name='System Performance Evaluation'>
      <topic importance='elective'> Why system performance needs to be evaluated  (cross-reference  SF/Performance/Figures of performance merit)
      </topic>
      <topic importance='elective'> What is to be evaluated  (cross-reference  SF/Performance/Figures of performance merit)
      </topic>
      <topic importance='elective'> Systems performance policies, e.g., caching, paging, scheduling, memory management, and security
      </topic>
      <topic importance='elective'> Evaluation models: deterministic, analytic, simulation, or  implementation-specific
      </topic>
      <topic importance='elective'> How to collect evaluation data (profiling and tracing mechanisms)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the performance measurements used to determine how a system performs. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the main evaluation models used to evaluate a system. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='PBD' name='Platform-based Development'>
    <knowledgeArea id='I' name='Introduction'>
      <topic importance='elective'> Overview of platforms (e.g., Web, Mobile, Game, Industrial)
      </topic>
      <topic importance='elective'> Programming via  platform-specific  APIs
      </topic>
      <topic importance='elective'> Overview of Platform Languages (e.g., Objective C, HTML5)
      </topic>
      <topic importance='elective'> Programming under platform constraints
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe how  platform-based  development differs from general purpose programming. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List characteristics of platform languages. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write and execute a simple  platform-based  program. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List the advantages and disadvantages of programming with platform constraints. </outcome>
    </knowledgeArea>
    <knowledgeArea id='WP' name='Web Platforms'>
      <topic importance='elective'> Web programming languages (e.g., HTML5, Java Script, PHP, CSS)
      </topic>
      <topic importance='elective'> Web platform constraints
      </topic>
      <topic importance='elective'> Software as a Service (SaaS)
      </topic>
      <topic importance='elective'> Web standards
      </topic>
      <outcome importance='elective' mastery_level='usage'>Design and Implement a simple web application. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the constraints that the web puts on developers. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast web programming with general purpose programming. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the differences between  Software-as-a-Service  and traditional software products. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss how web standards impact software development. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Review an existing web application against a current web standard. </outcome>
    </knowledgeArea>
    <knowledgeArea id='MP' name='Mobile Platforms'>
      <topic importance='elective'> Mobile programming languages
      </topic>
      <topic importance='elective'> Challenges with mobility and wireless communication
      </topic>
      <topic importance='elective'> Location-aware  applications
      </topic>
      <topic importance='elective'> Performance / power tradeoffs
      </topic>
      <topic importance='elective'> Mobile platform constraints
      </topic>
      <topic importance='elective'> Emerging technologies
      </topic>
      <outcome importance='elective' mastery_level='usage'>Design and implement a mobile application for a given mobile platform. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the constraints that mobile platforms put on developers. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the performance vs. power tradeoff. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast mobile programming with general purpose programming. </outcome>
    </knowledgeArea>
    <knowledgeArea id='IP' name='Industrial Platforms'>
      <topic importance='elective'> Types of Industrial Platforms (e.g., Mathematic, Robotic, Industrial Control)
      </topic>
      <topic importance='elective'> Robotic software and its architecture
      </topic>
      <topic importance='elective'> Domain-specific  languages
      </topic>
      <topic importance='elective'> Industrial platform constraints
      </topic>
      <outcome importance='elective' mastery_level='usage'>Design and implement an industrial application on a given platform (e.g., using Lego Mindstorms or Matlab). </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast domain specific languages with general purpose programming languages. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the constraints that a given industrial platforms impose on developers. </outcome>
    </knowledgeArea>
    <knowledgeArea id='GP' name='Game Platforms'>
      <topic importance='elective'> Types of game platforms (e.g., XBox, Wii, PlayStation)
      </topic>
      <topic importance='elective'> Game platform languages (e.g., C++, Java, Lua, Python)
      </topic>
      <topic importance='elective'> Game platform constraints
      </topic>
      <outcome importance='elective' mastery_level='usage'>Design and implement a simple application on a game platform. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the constraints that game platforms impose on developers. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare and contrast game programming with general purpose programming. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='PD' name='Parallel and Distributed Computing'>
    <knowledgeArea id='PF' name='Parallelism Fundamentals'>
      <topic importance='tier1'> Multiple simultaneous computations
      </topic>
      <topic importance='tier1'> Goals of parallelism (e.g., throughput) versus concurrency (e.g., controlling access to shared resources)
      </topic>
      <topic importance='tier1'> Parallelism, communication, and coordination</topic>
      <topic importance='tier1'> Programming constructs for coordinating multiple simultaneous computations</topic>
      <topic importance='tier1'> Need for synchronization</topic>
      <topic importance='tier1'> Programming errors not found in sequential programming</topic>
      <topic importance='tier1'> Data races (simultaneous read/write or write/write of shared state)</topic>
      <topic importance='tier1'>Higher-level  races (interleavings violating program intention, undesired  non-determinism)</topic>
      <topic importance='tier1'>ack of liveness/progress (deadlock, starvation)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Distinguish using computational resources for a faster answer from managing efficient access to a shared resource.  (Cross-reference  GV/Fundamental Concepts, outcome 5.) </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Distinguish multiple sufficient programming constructs for synchronization that may be inter- implementable but have complementary advantages. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Distinguish data races from higher level races. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PD' name='Parallel Decomposition'>
      <topic importance='tier1'> Need for communication and coordination/synchronization
      </topic>
      <topic importance='tier1'> Independence and partitioning
      </topic>
      <topic importance='tier2'> Basic knowledge of parallel decomposition concepts  (cross-reference  SF/System Support for Parallelism)
      </topic>
      <topic importance='tier2'> Task-based  decomposition</topic>
      <topic importance='tier2'> Implementation strategies such as threads</topic>
      <topic importance='tier2'> Data-parallel  decomposition</topic>
      <topic importance='tier2'> Strategies such as SIMD and MapReduce</topic>
      <topic importance='tier2'> Actors and reactive processes (e.g., request handlers)
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Explain why synchronization is necessary in a specific parallel program. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify opportunities to partition a serial program into independent parallel modules. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write a correct and scalable parallel algorithm. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Parallelize an algorithm by applying  task-based  decomposition. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Parallelize an algorithm by applying  data-parallel  decomposition. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write a program using actors and/or reactive processes. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CAC' name='Communication and Coordination'>
      <topic importance='tier1'> Shared Memory
      </topic>
      <topic importance='tier1'> Consistency, and its role in programming language guarantees for  data-race-free  programs
      </topic>
      <topic importance='tier2'> Message passing</topic>
      <topic importance='tier2'> Point-to-point  versus multicast (or  event-based)  messages</topic>
      <topic importance='tier2'> Blocking versus  non-blocking  styles for sending and receiving messages</topic>
      <topic importance='tier2'> Message buffering  (cross-reference  PF/Fundamental Data Structures/Queues)</topic>
      <topic importance='tier2'> Atomicity</topic>
      <topic importance='tier2'> Specifying and testing atomicity and safety requirements</topic>
      <topic importance='tier2'> Granularity of atomic accesses and updates, and the use of constructs such as critical sections or transactions to describe them</topic>
      <topic importance='tier2'> Mutual Exclusion using locks, semaphores, monitors, or related constructs</topic>
      <topic importance='elective'> Consensus</topic>
      <topic importance='elective'> (Cyclic) barriers, counters, or related constructs</topic>
      <topic importance='elective'> Conditional actions</topic>
      <topic importance='elective'> Conditional waiting (e.g., using condition variables)</topic>
      <outcome importance='tier1' mastery_level='usage'>Use mutual exclusion to avoid a given race condition. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Give an example of an ordering of accesses among concurrent activities (e.g., program with a data race) that is not sequentially consistent. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Give an example of a scenario in which blocking message sends can deadlock. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain when and why multicast or  event-based  messaging can be preferable to alternatives. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write a program that correctly terminates when all of a set of concurrent tasks have completed. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use a properly synchronized queue to buffer data passed among activities. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain why checks for preconditions, and actions based on these checks, must share the same unit of atomicity to be effective. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write a test program that can reveal a concurrent programming error; for example, missing an update when two activities both try to increment a variable. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe at least one design technique for avoiding liveness failures in programs using multiple locks or semaphores. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the relative merits of optimistic versus conservative concurrency control under different rates of contention among updates. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Give an example of a scenario in which an attempted optimistic update may never complete. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use semaphores or condition variables to block threads until a necessary precondition holds. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PAAAP' name='Parallel Algorithms, Analysis, and Programming'>
      <topic importance='tier2'> Critical paths, work and span, and the relation to Amdahl’s law  (cross-reference  SF/Performance)
      </topic>
      <topic importance='tier2'> Speed-up  and scalability
      </topic>
      <topic importance='tier2'> Naturally (embarrassingly) parallel algorithms
      </topic>
      <topic importance='tier2'> Parallel algorithmic patterns  (divide-and-conquer,  map and reduce,  master-workers,  others)</topic>
      <topic importance='tier2'> Specific algorithms (e.g., parallel MergeSort)</topic>
      <topic importance='elective'> Parallel graph algorithms (e.g., parallel shortest path, parallel spanning tree)  (cross-reference  AL/Algorithmic  Strategies/Divide-and-conquer)
      </topic>
      <topic importance='elective'> Parallel matrix computations
      </topic>
      <topic importance='elective'> Producer-consumer  and pipelined algorithms
      </topic>
      <topic importance='elective'> Examples of  non-scalable  parallel algorithms
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Define “critical path”, “work”, and “span”. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Compute the work and span, and determine the critical path with respect to a parallel execution diagram. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Define  “speed-up”  and explain the notion of an algorithm’s scalability in this regard. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify independent tasks in a program that may be parallelized. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Characterize features of a workload that allow or prevent it from being naturally parallelized. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Implement a parallel  divide-and-conquer  (and/or graph algorithm) and empirically measure its performance relative to its sequential analog. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Decompose a problem (e.g., counting the number of occurrences of some word in a document) via map and reduce operations. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Provide an example of a problem that fits the  producer-consumer  paradigm. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Give examples of problems where pipelining would be an effective means of parallelization. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a parallel matrix algorithm. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify issues that arise in  producer-consumer  algorithms and mechanisms that may be used for addressing them. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PA' name='Parallel Architecture'>
      <topic importance='tier1'> Multicore processors
      </topic>
      <topic importance='tier1'> Shared vs. distributed memory
      </topic>
      <topic importance='tier2'> Symmetric multiprocessing (SMP)
      </topic>
      <topic importance='tier2'> SIMD, vector processing
      </topic>
      <topic importance='elective'> GPU,  co-processing
      </topic>
      <topic importance='elective'> Flynn’s taxonomy
      </topic>
      <topic importance='elective'> Instruction level support for parallel programming</topic>
      <topic importance='elective'> Atomic instructions such as Compare and Set</topic>
      <topic importance='elective'> Memory issues</topic>
      <topic importance='elective'> Multiprocessor caches and cache coherence</topic>
      <topic importance='elective'> Non-uniform  memory access (NUMA)</topic>
      <topic importance='elective'> Topologies</topic>
      <topic importance='elective'>Interconnects</topic>
      <topic importance='elective'>lusters</topic>
      <topic importance='elective'>  Resource sharing (e.g., buses and interconnects)</topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the differences between shared and distributed memory. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the SMP architecture and note its key features. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the advantages and limitations of GPUs vs. CPUs. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the features of each classification in Flynn’s taxonomy. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe  assembly-level  support for atomic operations. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the challenges in maintaining cache coherence. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the key performance challenges in different memory and distributed system topologies. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PP' name='Parallel Performance'>
      <topic importance='elective'> Load balancing
      </topic>
      <topic importance='elective'> Performance measurement
      </topic>
      <topic importance='elective'> Scheduling and contention  (cross-reference  OS/Scheduling and Dispatch)
      </topic>
      <topic importance='elective'> Evaluating communication overhead
      </topic>
      <topic importance='elective'> Data management</topic>
      <topic importance='elective'>Non-uniform  communication costs due to proximity  (cross-reference  SF/Proximity)</topic>
      <topic importance='elective'>ache effects (e.g., false sharing)</topic>
      <topic importance='elective'>  Maintaining spatial locality</topic>
      <topic importance='elective'> Power usage and management
      </topic>
      <outcome importance='elective' mastery_level='usage'>Detect and correct a load imbalance. </outcome>
      <outcome importance='elective' mastery_level='usage'>Calculate the implications of Amdahl’s law for a particular parallel algorithm  (cross-reference  SF/Evaluation for Amdahl’s Law). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how data distribution/layout can affect an algorithm’s communication costs. </outcome>
      <outcome importance='elective' mastery_level='usage'>Detect and correct an instance of false sharing. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the impact of scheduling on parallel performance. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain performance impacts of data locality. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the impact and  trade-off  related to power usage on parallel performance. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DS' name='Distributed Systems'>
      <topic importance='elective'> Faults  (cross-reference  OS/Fault Tolerance)</topic>
      <topic importance='elective'> Network-based  (including partitions) and  node-based  failures</topic>
      <topic importance='elective'> Impact on  system-wide  guarantees (e.g., availability)</topic>
      <topic importance='elective'> Distributed message sending</topic>
      <topic importance='elective'> Data conversion and transmission</topic>
      <topic importance='elective'> Sockets</topic>
      <topic importance='elective'> Message sequencing</topic>
      <topic importance='elective'> Buffering, retrying, and dropping messages</topic>
      <topic importance='elective'> Distributed system design tradeoffs</topic>
      <topic importance='elective'> Latency versus throughput</topic>
      <topic importance='elective'> Consistency, availability, partition tolerance</topic>
      <topic importance='elective'> Distributed service design</topic>
      <topic importance='elective'> Stateful versus stateless protocols and services</topic>
      <topic importance='elective'> Session  (connection-based)  designs</topic>
      <topic importance='elective'> Reactive  (IO-triggered)  and multithreaded designs</topic>
      <topic importance='elective'> Core distributed algorithms</topic>
      <topic importance='elective'> Election, discovery</topic>
      <outcome importance='elective' mastery_level='familiarity'>Distinguish network faults from other kinds of failures. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain why synchronization constructs such as simple locks are not useful in the presence of distributed faults. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write a program that performs any required marshaling and conversion into message units, such as packets, to communicate interesting data between two hosts. </outcome>
      <outcome importance='elective' mastery_level='usage'>Measure the observed throughput and response latency across hosts in a given network. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain why no distributed system can be simultaneously consistent, available, and partition tolerant. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a simple server  --  for example, a spell checking service. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the tradeoffs among overhead, scalability, and fault tolerance when choosing a stateful v. stateless design for a given service. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the scalability challenges associated with a service growing to accommodate many clients, as well as those associated with a service only transiently having many clients. </outcome>
      <outcome importance='elective' mastery_level='usage'>Give examples of problems for which consensus algorithms such as leader election are required. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CC' name='Cloud Computing'>
      <topic importance='elective'> Internet-Scale  computing</topic>
      <topic importance='elective'> Task partitioning  (cross-reference  PD/Parallel Algorithms, Analysis, and Programming)</topic>
      <topic importance='elective'> Data access</topic>
      <topic importance='elective'> Clusters, grids, and meshes</topic>
      <topic importance='elective'> Cloud services</topic>
      <topic importance='elective'> Infrastructure as a service</topic>
      <topic importance='elective'> Software as a service</topic>
      <topic importance='elective'> Security</topic>
      <topic importance='elective'> Cost management</topic>
      
      <topic importance='elective'> Virtualization  (cross-reference  SF/Virtualization and Isolation and OS/Virtual Machines)</topic>
      <topic importance='elective'> Shared resource management</topic>
      <topic importance='elective'> Migration of processes</topic>
      <topic importance='elective'> Cloud-based  data storage</topic>
      <topic importance='elective'> Shared access to weakly consistent data stores</topic>
      <topic importance='elective'> Data synchronization</topic>
      <topic importance='elective'> Data partitioning</topic>
      <topic importance='elective'> Distributed file systems  (cross-reference  IM/Distributed Databases)</topic>
      <topic importance='elective'> Replication</topic>
      
      <outcome importance='elective' mastery_level='familiarity'>Discuss the importance of elasticity and resource management in cloud computing. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain strategies to synchronize a common view of shared data across a collection of devices. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the advantages and disadvantages of using virtualized infrastructure. </outcome>
      <outcome importance='elective' mastery_level='usage'>Deploy an application that uses cloud infrastructure for computing and/or data resources. </outcome>
      <outcome importance='elective' mastery_level='usage'>Appropriately partition an application between a client and resources. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FMAS' name='Formal Models and Semantics'>
      <topic importance='elective'> Formal models of processes and message passing, including algebras such as Communicating Sequential Processes (CSP) and  pi-calculus
      </topic>
      <topic importance='elective'> Formal models of parallel computation, including the Parallel Random Access Machine (PRAM) and alternatives such as Bulk Synchronous Parallel (BSP)
      </topic>
      <topic importance='elective'> Formal models of computational dependencies
      </topic>
      <topic importance='elective'> Models of (relaxed) shared memory consistency and their relation to programming language specifications
      </topic>
      <topic importance='elective'> Algorithmic correctness criteria including linearizability
      </topic>
      <topic importance='elective'> Models of algorithmic progress, including  non-blocking  guarantees and fairness
      </topic>
      <topic importance='elective'> Techniques for specifying and checking correctness properties such as atomicity and freedom from data races
      </topic>
      <outcome importance='elective' mastery_level='usage'>Model a concurrent process using a formal model, such as  pi-calculus.  </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the characteristics of a particular formal parallel model. </outcome>
      <outcome importance='elective' mastery_level='usage'>Formally model a shared memory system to show if it is consistent. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use a model to show progress guarantees in a parallel algorithm. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use formal techniques to show that a parallel algorithm is correct with respect to a safety or liveness property. </outcome>
      <outcome importance='elective' mastery_level='usage'>Decide if a specific execution is linearizable or not. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='PL' name='Programming Languages'>
    <knowledgeArea id='OP' name='Object-Oriented  Programming'>
      <topic importance='tier1'> Object-oriented  design</topic>
      <topic importance='tier1'>Decomposition into objects carrying state and having behavior</topic>
      <topic importance='tier1'>lass-hierarchy  design for modeling
      </topic>
      <topic importance='tier1'> Definition of classes: fields, methods, and constructors
      </topic>
      <topic importance='tier1'> Subclasses, inheritance, and method overriding
      </topic>
      <topic importance='tier1'> Dynamic dispatch: definition of  method-call
      </topic>
      <topic importance='tier2'> Subtyping  (cross-reference  PL/Type Systems)</topic>
      <topic importance='tier2'> Subtype polymorphism; implicit upcasts in typed languages</topic>
      <topic importance='tier2'> Notion of behavioral replacement: subtypes acting like supertypes</topic>
      <topic importance='tier2'> Relationship between subtyping and inheritance</topic>
      <topic importance='tier2'> Object-oriented  idioms for encapsulation</topic>
      <topic importance='tier2'> Privacy and visibility of class members</topic>
      <topic importance='tier2'>Interfaces revealing only method signatures</topic>
      <topic importance='tier2'>bstract base classes
      </topic>
      <topic importance='tier2'> Using collection classes, iterators, and other common library components
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Design and implement a class. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use subclassing to design simple class hierarchies that allow code to be reused for distinct subclasses. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Correctly reason about control flow in a program using dynamic dispatch. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the relationship between  object-oriented  inheritance  (code-sharing  and overriding) and subtyping (the idea of a subtype being usable in a context that expects the supertype). </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use  object-oriented  encapsulation mechanisms such as interfaces and private members. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FP' name='Functional Programming'>
      <topic importance='tier1'> Effect-free  programming</topic>
      <topic importance='tier1'> Function calls have no side effects, facilitating compositional reasoning</topic>
      <topic importance='tier1'> Variables are immutable, preventing unexpected changes to program data by other code</topic>
      <topic importance='tier1'> Data can be freely aliased or copied without introducing unintended effects from mutation</topic>
      <topic importance='tier1'> Processing structured data (e.g., trees) via functions with cases for each data variant</topic>
      <topic importance='tier1'> Associated language constructs such as discriminated unions and  pattern-matching  over them</topic>
      <topic importance='tier1'> Functions defined over compound data in terms of functions applied to the constituent pieces</topic>
      <topic importance='tier1'> First-class  functions (taking, returning, and storing functions)
      </topic>
      <topic importance='tier2'> Function closures (functions using variables in the enclosing lexical environment)</topic>
      <topic importance='tier2'>Basic meaning and definition  --  creating closures at  run-time  by capturing the environment  o  Canonical idioms:  call-backs,  arguments to iterators, reusable code via function arguments</topic>
      <topic importance='tier2'>sing a closure to encapsulate data in its environment</topic>
      <topic importance='tier2'>  Currying and partial application</topic>
      <topic importance='tier2'> Defining  higher-order  operations on aggregates, especially map, reduce/fold, and filter
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Write basic algorithms that avoid assigning to mutable state or considering reference equality. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write useful functions that take and return other functions. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Correctly reason about variables and lexical scope in a program using function closures. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use functional encapsulation mechanisms such as closures and modular interfaces. </outcome>
    </knowledgeArea>
    <knowledgeArea id='EARP' name='Event-Driven  and Reactive Programming'>
      <topic importance='tier2'> Events and event handlers
      </topic>
      <topic importance='tier2'> Canonical uses such as GUIs, mobile devices, robots, servers
      </topic>
      <topic importance='tier2'> Using a reactive framework</topic>
      <topic importance='tier2'> Defining event handlers/listeners</topic>
      <topic importance='tier2'> Main event loop not under  event-handler-writer’s  control</topic>
      <topic importance='tier2'> Externally-generated  events and  program-generated  events
      </topic>
      <topic importance='tier2'> Separation of model, view, and controller
      </topic>
      <outcome importance='tier2' mastery_level='usage'>Write event handlers for use in reactive systems, such as GUIs. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain why an  event-driven  programming style is natural in domains where programs react to external events. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe an interactive system in terms of a model, a view, and a controller. </outcome>
    </knowledgeArea>
    <knowledgeArea id='BTS' name='Basic Type Systems'>
      <topic importance='tier1'>A type as a set of values together with a set of operations
      </topic>
      <topic importance='tier1'>rimitive types (e.g., numbers, Booleans)</topic>
      <topic importance='tier1'>  Compound types built from other types (e.g., records, unions, arrays, lists, functions, references)</topic>
      <topic importance='tier1'> Association of types to variables, arguments, results, and fields
      </topic>
      <topic importance='tier1'> Type safety and errors caused by using values inconsistently given their intended types
      </topic>
      <topic importance='tier1'> Goals and limitations of static typing</topic>
      <topic importance='tier1'> Eliminating some classes of errors without running the program</topic>
      <topic importance='tier1'> Undecidability means static analysis must conservatively approximate program behavior</topic>
      <topic importance='tier2'>Generic types (parametric polymorphism)
      </topic>
      <topic importance='tier2'>efinition</topic>
      <topic importance='tier2'>  Use for generic libraries such as collections</topic>
      <topic importance='tier2'>  Comparison with ad hoc polymorphism (overloading) and subtype polymorphism</topic>
      <topic importance='tier2'> Complementary benefits of static and dynamic typing</topic>
      <topic importance='tier2'> Errors early vs. errors late/avoided</topic>
      <topic importance='tier2'> Enforce invariants during code development and code maintenance vs. postpone typing decisions while prototyping and conveniently allow flexible coding patterns such as heterogeneous</topic>
      <topic importance='tier2'> Avoid misuse of code vs. allow more code reuse</topic>
      <topic importance='tier2'> Detect incomplete programs vs. allow incomplete programs to run</topic>
      <outcome importance='tier1' mastery_level='familiarity'>For both a primitive and a compound type, informally describe the values that have that type. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>For a language with a static type system, describe the operations that are forbidden statically, such as passing the wrong type of value to a function or method. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe examples of program errors detected by a type system. </outcome>
      <outcome importance='tier1' mastery_level='usage'>For multiple programming languages, identify program properties checked statically and program properties checked dynamically. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Give an example program that does not  type-check  in a particular language and yet would have no error if run. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use types and  type-error  messages to write and debug programs. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how typing rules define the set of operations that are legal for a type. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write down the type rules governing the use of a particular compound type. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain why undecidability requires type systems to conservatively approximate program behavior. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Define and use program pieces (such as functions, classes, methods) that use generic types, including for collections. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the differences among generics, subtyping, and overloading. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging software. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PR' name='Program Representation'>
      <topic importance='tier2'> Programs that take (other) programs as input such as interpreters, compilers,  type-checkers,  documentation generators
      </topic>
      <topic importance='tier2'> Abstract syntax trees; contrast with concrete syntax
      </topic>
      <topic importance='tier2'> Data structures to represent code for execution, translation, or transmission
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how programs that process other programs treat the other programs as their input data. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Describe an abstract syntax tree for a small language. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the benefits of having program representations other than strings of source code. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Write a program to process some representation of code for some purpose, such as an interpreter, an expression optimizer, or a documentation generator. </outcome>
    </knowledgeArea>
    <knowledgeArea id='LTAE' name='Language Translation and Execution'>
      <topic importance='tier2'> Interpretation vs. compilation to native code vs. compilation to portable intermediate representation
      </topic>
      <topic importance='tier2'> Language translation pipeline: parsing, optional  type-checking,  translation, linking, execution</topic>
      <topic importance='tier2'> Execution as native code or within a virtual machine</topic>
      <topic importance='tier2'> Alternatives like dynamic loading and dynamic (or  “just-in-time”)  code generation</topic>
      <topic importance='tier2'> Run-time  representation of core language constructs such as objects (method tables) and  first-class  functions (closures)</topic>
      <topic importance='tier2'> Run-time  layout of memory:  call-stack,  heap, static data</topic>
      <topic importance='tier2'> Implementing loops, recursion, and tail calls</topic>
      
      <topic importance='tier2'> Memory management</topic>
      <topic importance='tier2'> Manual memory management: allocating,  de-allocating,  and reusing heap memory</topic>
      <topic importance='tier2'> Automated memory management: garbage collection as an automated technique using the notion of reachability</topic>
      
      <outcome importance='tier2' mastery_level='familiarity'>Distinguish a language definition (what constructs mean) from a particular language implementation (compiler vs. interpreter,  run-time  representation of data objects, etc.). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Distinguish syntax and parsing from semantics and evaluation. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Sketch a  low-level   run-time  representation of core language constructs, such as objects or closures. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how programming language implementations typically organize memory into global data, text, heap, and stack sections and how features such as recursion and memory management map to this memory model. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify and fix memory leaks and  dangling-pointer  dereferences. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the benefits and limitations of garbage collection, including the notion of reachability. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SA' name='Syntax Analysis'>
      <topic importance='elective'> Scanning (lexical analysis) using regular expressions
      </topic>
      <topic importance='elective'> Parsing strategies including  top-down  (e.g., recursive descent, Earley parsing, or LL) and  bottom-up  (e.g., backtracking or LR) techniques; role of  context-free  grammars
      </topic>
      <topic importance='elective'> Generating scanners and parsers from declarative specifications
      </topic>
      <outcome importance='elective' mastery_level='usage'>Use formal grammars to specify the syntax of languages. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use declarative tools to generate parsers and scanners. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify key issues in syntax definitions: ambiguity, associativity, precedence. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CSA' name='Compiler Semantic Analysis'>
      <topic importance='elective'> High-level  program representations such as abstract syntax trees
      </topic>
      <topic importance='elective'> Scope and binding resolution
      </topic>
      <topic importance='elective'> Type checking
      </topic>
      <topic importance='elective'> Declarative specifications such as attribute grammars
      </topic>
      <outcome importance='elective' mastery_level='usage'>Implement  context-sensitive,   source-level  static analyses such as  type-checkers  or resolving identifiers to identify their binding occurrences. </outcome>
      <outcome importance='elective' mastery_level='usage'>Describe semantic analyses using an attribute grammar. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CG' name='Code Generation'>
      <topic importance='elective'> Procedure calls and method dispatching
      </topic>
      <topic importance='elective'> Separate compilation; linking
      </topic>
      <topic importance='elective'> Instruction selection
      </topic>
      <topic importance='elective'> Instruction scheduling
      </topic>
      <topic importance='elective'> Register allocation
      </topic>
      <topic importance='elective'> Peephole optimization
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Identify all essential steps for automatically converting source code into assembly or other  low-level  languages. </outcome>
      <outcome importance='elective' mastery_level='usage'>Generate the  low-level  code for calling functions/methods in modern languages. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss why separate compilation requires uniform calling conventions. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss why separate compilation limits optimization because of unknown effects of calls. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss opportunities for optimization introduced by naive translation and approaches for achieving optimization, such as instruction selection, instruction scheduling, register allocation, and peephole optimization. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RS' name='Runtime Systems'>
      <topic importance='elective'> Dynamic memory management approaches and techniques: malloc/free, garbage collection  (mark-sweep,  copying, reference counting), regions (also known as arenas or zones)
      </topic>
      <topic importance='elective'> Data layout for objects and activation records
      </topic>
      <topic importance='elective'> Just-in-time  compilation and dynamic recompilation
      </topic>
      <topic importance='elective'> Other common features of virtual machines, such as class loading, threads, and security.
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Compare the benefits of different  memory-management  schemes, using concepts such as fragmentation, locality, and memory overhead. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss benefits and limitations of automatic memory management. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the use of metadata in  run-time  representations of objects and activation records, such as class pointers, array lengths, return addresses, and frame pointers. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss advantages, disadvantages, and difficulties of  just-in-time  and dynamic recompilation. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the services provided by modern language  run-time  systems. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SA2' name='Static Analysis'>
      <topic importance='elective'> Relevant program representations, such as basic blocks,  control-flow  graphs,  def-use  chains, and static single assignment
      </topic>
      <topic importance='elective'> Undecidability and consequences for program analysis
      </topic>
      <topic importance='elective'> Flow-insensitive  analyses, such as  type-checking  and scalable pointer and alias analyses
      </topic>
      <topic importance='elective'> Flow-sensitive  analyses, such as forward and backward dataflow analyses
      </topic>
      <topic importance='elective'> Path-sensitive  analyses, such as software model checking
      </topic>
      <topic importance='elective'> Tools and frameworks for defining analyses
      </topic>
      <topic importance='elective'> Role of static analysis in program optimization
      </topic>
      <topic importance='elective'> Role of static analysis in (partial) verification and  bug-finding
      </topic>
      <outcome importance='elective' mastery_level='usage'>Define useful static analyses in terms of a conceptual framework such as dataflow analysis. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain why  non-trivial  sound static analyses must be approximate. </outcome>
      <outcome importance='elective' mastery_level='usage'>Communicate why an analysis is correct (sound and terminating). </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Distinguish “may” and “must” analyses. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain why potential aliasing limits sound program analysis and how alias analysis can help. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use the results of a static analysis for program optimization and/or partial program correctness. </outcome>
    </knowledgeArea>
    <knowledgeArea id='APC' name='Advanced Programming Constructs'>
      <topic importance='elective'> Lazy evaluation and infinite streams
      </topic>
      <topic importance='elective'> Control Abstractions: Exception Handling, Continuations, Monads
      </topic>
      <topic importance='elective'> Object-oriented  abstractions: Multiple inheritance, Mixins, Traits, Multimethods
      </topic>
      <topic importance='elective'> Metaprogramming: Macros, Generative programming,  Model-based  development
      </topic>
      <topic importance='elective'> Module systems
      </topic>
      <topic importance='elective'> String manipulation via  pattern-matching  (regular expressions)
      </topic>
      <topic importance='elective'> Dynamic code evaluation (“eval”)
      </topic>
      <topic importance='elective'> Language support for checking assertions, invariants, and  pre/post-conditions
      </topic>
      <outcome importance='elective' mastery_level='usage'>Use various advanced programming constructs and idioms correctly. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss how various advanced programming constructs aim to improve program structure, software quality, and programmer productivity. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss how various advanced programming constructs interact with the definition and implementation of other language features. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CAP' name='Concurrency and Parallelism'>
      <topic importance='elective'> Constructs for  thread-shared  variables and  shared-memory  synchronization
      </topic>
      <topic importance='elective'> Actor models
      </topic>
      <topic importance='elective'> Futures
      </topic>
      <topic importance='elective'> Language support for data parallelism
      </topic>
      <topic importance='elective'> Models for passing messages between sequential processes
      </topic>
      <topic importance='elective'> Effect of  memory-consistency  models on language semantics and correct code generation
      </topic>
      <outcome importance='elective' mastery_level='usage'>Write correct concurrent programs using multiple programming models, such as shared memory, actors, futures, and  data-parallelism  primitives. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use a  message-passing  model to analyze a communication protocol. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain why programming languages do not guarantee sequential consistency in the presence of data races and what programmers must do as a result. </outcome>
    </knowledgeArea>
    <knowledgeArea id='TS' name='Type Systems'>
      <topic importance='elective'> Compositional type constructors, such as product types (for aggregates), sum types (for unions), function types, quantified types, and recursive types
      </topic>
      <topic importance='elective'> Type checking
      </topic>
      <topic importance='elective'> Type safety as preservation plus progress
      </topic>
      <topic importance='elective'> Type inference
      </topic>
      <topic importance='elective'> Static overloading
      </topic>
      <outcome importance='elective' mastery_level='usage'>Define a type system precisely and compositionally. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>For various foundational type constructors, identify the values they describe and the invariants they enforce. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Precisely specify the invariants preserved by a sound type system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Prove type safety for a simple language in terms of preservation and progress theorems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Implement a  unification-based   type-inference  algorithm for a simple language. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain how static overloading and associated resolution algorithms influence the dynamic behavior of programs. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FS' name='Formal Semantics'>
      <topic importance='elective'> Syntax vs. semantics
      </topic>
      <topic importance='elective'> Lambda Calculus
      </topic>
      <topic importance='elective'> Approaches to semantics: Operational, Denotational, Axiomatic
      </topic>
      <topic importance='elective'> Proofs by induction over language semantics
      </topic>
      <topic importance='elective'> Formal definitions and proofs for type systems  (cross-reference  PL/Type Systems)
      </topic>
      <topic importance='elective'> Parametricity  (cross-reference  PL/Type Systems)
      </topic>
      <topic importance='elective'> Using formal semantics for systems modeling
      </topic>
      <outcome importance='elective' mastery_level='usage'>Give a formal semantics for a small language. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write a  lambda-calculus  program and show its evaluation to a normal form. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the different approaches of operational, denotational, and axiomatic semantics. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use induction to prove properties of all programs in a language. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use induction to prove properties of all programs in a language that are  well-typed  according to a formally defined type system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use parametricity to establish the behavior of code given only its type. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use formal semantics to build a formal model of a software system other than a programming language. </outcome>
    </knowledgeArea>
    <knowledgeArea id='LP' name='Language Pragmatics'>
      <topic importance='elective'> Principles of language design such as orthogonality
      </topic>
      <topic importance='elective'> Evaluation order, precedence, and associativity
      </topic>
      <topic importance='elective'> Eager vs. delayed evaluation
      </topic>
      <topic importance='elective'> Defining control and iteration constructs
      </topic>
      <topic importance='elective'> External calls and system libraries
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the role of concepts such as orthogonality and  well-chosen  defaults in language design. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use crisp and objective criteria for evaluating  language-design  decisions. </outcome>
      <outcome importance='elective' mastery_level='usage'>Give an example program whose result can differ under different rules for evaluation order, precedence, or associativity. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Show uses of delayed evaluation, such as  user-defined  control abstractions. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the need for allowing calls to external calls and system libraries and the consequences for language implementation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='LP2' name='Logic Programming'>
      <topic importance='elective'> Clausal representation of data structures and algorithms
      </topic>
      <topic importance='elective'> Unification
      </topic>
      <topic importance='elective'> Backtracking and search
      </topic>
      <topic importance='elective'> Cuts
      </topic>
      <outcome importance='elective' mastery_level='usage'>Use a logic language to implement a conventional algorithm. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use a logic language to implement an algorithm employing implicit search using clauses, relations, and cuts. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='SDF' name='Software Development Fundamentals'>
    <knowledgeArea id='AAD' name='Algorithms and Design'>
      <topic importance='tier1'> The concept and properties of algorithms</topic>
      <topic importance='tier1'> Informal comparison of algorithm efficiency (e.g., operation counts)</topic>
      <topic importance='tier1'> The role of algorithms in the  problem-solving  process
      </topic>
      <topic importance='tier1'> Problem-solving  strategies</topic>
      <topic importance='tier1'> Iterative and recursive mathematical functions</topic>
      <topic importance='tier1'> Iterative and recursive traversal of data structures</topic>
      <topic importance='tier1'> Divide-and-conquer  strategies</topic>
      <topic importance='tier1'> Fundamental design concepts and principles</topic>
      <topic importance='tier1'> Abstraction</topic>
      <topic importance='tier1'> Program decomposition</topic>
      <topic importance='tier1'> Encapsulation and information hiding</topic>
      <topic importance='tier1'> Separation of behavior and implementation</topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the importance of algorithms in the  problem-solving  process. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss how a problem may be solved by multiple algorithms, each with different properties. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Create algorithms for solving simple problems. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use a programming language to implement, test, and debug algorithms for solving simple problems. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Implement, test, and debug simple recursive functions and procedures. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Determine whether a recursive or iterative solution is most appropriate for a problem. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Implement a  divide-and-conquer  algorithm for solving a problem. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply the techniques of decomposition to break a program into smaller pieces. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Identify the data components and behaviors of multiple abstract data types. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Implement a coherent abstract data type, with loose coupling between components and behaviors. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Identify the relative strengths and weaknesses among multiple designs or implementations for a problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FPC' name='Fundamental Programming Concepts'>
      <topic importance='tier1'> Basic syntax and semantics of a  higher-level  language
      </topic>
      <topic importance='tier1'> Variables and primitive data types (e.g., numbers, characters, Booleans)
      </topic>
      <topic importance='tier1'> Expressions and assignments
      </topic>
      <topic importance='tier1'> Simple I/O including file I/O
      </topic>
      <topic importance='tier1'> Conditional and iterative control structures
      </topic>
      <topic importance='tier1'> Functions and parameter passing
      </topic>
      <topic importance='tier1'> The concept of recursion
      </topic>
      <outcome importance='tier1' mastery_level='assessment'>Analyze and explain the behavior of simple programs involving the fundamental programming constructs variables, expressions, assignments, I/O, control constructs, functions, parameter passing, and recursion. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify and describe uses of primitive data types. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write programs that use primitive data types. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Modify and expand short programs that use standard conditional and iterative control structures and functions. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Design, implement, test, and debug a program that uses each of the following fundamental programming constructs: basic computation, simple I/O, standard conditional and iterative structures, the definition of functions, and parameter passing. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write a program that uses file I/O to provide persistence across multiple executions. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Choose appropriate conditional and iteration constructs for a given programming task. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the concept of recursion and give examples of its use. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Identify the base case and the general case of a  recursively-defined  problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FDS' name='Fundamental Data Structures'>
      <topic importance='tier1'> Arrays
      </topic>
      <topic importance='tier1'> Records/structs (heterogeneous aggregates)
      </topic>
      <topic importance='tier1'> Strings and string processing
      </topic>
      <topic importance='tier1'>Abstract data types and their implementation
      </topic>
      <topic importance='tier1'>tacks</topic>
      <topic importance='tier1'>  Queues</topic>
      <topic importance='tier1'>Priority queues</topic>
      <topic importance='tier1'>ets</topic>
      <topic importance='tier1'>  Maps</topic>
      <topic importance='tier1'> References and aliasing
      </topic>
      <topic importance='tier1'> Linked lists
      </topic>
      <topic importance='tier1'> Strategies for choosing the appropriate data structure
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the appropriate use of  built-in  data structures. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe common applications for each of the following data structures: stack, queue, priority queue, set, and map. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists, stacks, queues, sets, and maps. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Compare alternative implementations of data structures with respect to performance. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how references allow for objects to be accessed in multiple ways. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Compare and contrast the costs and benefits of dynamic and static data structure implementations. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Choose the appropriate data structure for modeling a given problem. </outcome>
    </knowledgeArea>
    <knowledgeArea id='DM' name='Development Methods'>
      <topic importance='tier1'> Program comprehension
      </topic>
      <topic importance='tier1'> Program correctness</topic>
      <topic importance='tier1'> Types of errors (syntax, logic,  run-time)</topic>
      <topic importance='tier1'> The concept of a specification</topic>
      <topic importance='tier1'> Defensive programming (e.g. secure coding, exception handling)</topic>
      <topic importance='tier1'> Code reviews</topic>
      <topic importance='tier1'> Testing fundamentals and  test-case  generation</topic>
      <topic importance='tier1'> The role and the use of contracts, including pre- and  post-conditions</topic>
      <topic importance='tier1'> Unit testing</topic>
      <topic importance='tier1'> Simple refactoring
      </topic>
      <topic importance='tier1'> Modern programming environments</topic>
      <topic importance='tier1'> Code search</topic>
      <topic importance='tier1'> Programming using library components and their APIs</topic>
      <topic importance='tier1'> Debugging strategies
      </topic>
      <topic importance='tier1'> Documentation and program style
      </topic>
      <outcome importance='tier1' mastery_level='assessment'>Trace the execution of a variety of code segments and write summaries of their computations. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain why the creation of correct program components is important in the production of  high-quality  software. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Identify common coding errors that lead to insecure programs (e.g., buffer overflows, memory leaks, malicious code) and apply strategies for avoiding such errors. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Conduct a personal code review (focused on common coding errors) on a program component using a provided checklist. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Contribute to a  small-team  code review focused on component correctness. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how a contract can be used to specify the behavior of a program component. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Refactor a program by identifying opportunities to apply procedural abstraction. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply a variety of strategies to the testing and debugging of simple programs. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Construct, execute and debug programs using a modern IDE and associated tools such as unit testing tools and visual debuggers. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Construct and debug programs using the standard libraries available with a chosen programming language. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Analyze the extent to which another programmer’s code meets documentation and programming style standards. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Apply consistent documentation and program style standards that contribute to the readability and maintainability of software. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='SE' name='Software Engineering'>
    <knowledgeArea id='SP' name='Software Processes'>
      <topic importance='tier1'> Systems level considerations, i.e., the interaction of software with its intended environment (cross- reference IAS/Secure Software Engineering)
      </topic>
      <topic importance='tier1'> Introduction to software process models (e.g., waterfall, incremental, agile)</topic>
      <topic importance='tier1'> Activities within software lifecycles</topic>
      <topic importance='tier1'> Programming in the large vs. individual programming
      </topic>
      <topic importance='tier2'> Evaluation of software process models
      </topic>
      <topic importance='elective'> Software quality concepts
      </topic>
      <topic importance='elective'> Process improvement
      </topic>
      <topic importance='elective'> Software process capability maturity models
      </topic>
      <topic importance='elective'> Software process measurements
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how software can interact with and participate in various systems including information management, embedded, process control, and communications systems. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the relative advantages and disadvantages among several major process models (e.g., waterfall, iterative, and agile). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the different practices that are key components of various process models. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Differentiate among the phases of software development. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how programming in the large differs from individual efforts with respect to understanding a large code base, code reading, understanding builds, and understanding context of changes. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the concept of a software lifecycle and provide an example, illustrating its phases including the deliverables that are produced. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Compare several common process models with respect to their value for development of particular classes of software systems taking into account issues such as requirement stability, size, and  non-functional  characteristics. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Define software quality and describe the role of quality assurance activities in the software process. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the intent and fundamental similarities among process improvement approaches. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare several process improvement models such as CMM, CMMI, CQI,  Plan-Do-Check-Act,  or ISO9000. </outcome>
      <outcome importance='elective' mastery_level='usage'>Assess a development effort and recommend potential changes by participating in process improvement (using a model such as PSP) or engaging in a project retrospective. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the role of process maturity models in process improvement. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe several process metrics for assessing and controlling a project. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use project metrics to describe the current state of a project. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SPM' name='Software Project Management'>
      <topic importance='tier2'> Team participation</topic>
      <topic importance='tier2'> Team processes including responsibilities for tasks, meeting structure, and work schedule</topic>
      <topic importance='tier2'> Roles and responsibilities in a software team</topic>
      <topic importance='tier2'> Team conflict resolution</topic>
      <topic importance='tier2'> Risks associated with virtual teams (communication, perception, structure)</topic>
      <topic importance='tier2'> Effort Estimation (at the personal level)
      </topic>
      <topic importance='tier2'> Risk (cross reference IAS/Secure Software Engineering)</topic>
      <topic importance='tier2'> The role of risk in the lifecycle</topic>
      <topic importance='tier2'> Risk categories including security, safety, market, financial, technology, people, quality, structure and process</topic>
      <topic importance='elective'> Team management</topic>
      <topic importance='elective'> Team organization and  decision-making</topic>
      <topic importance='elective'> Role identification and assignment</topic>
      <topic importance='elective'> Individual and team performance assessment</topic>
      <topic importance='elective'> Project management</topic>
      <topic importance='elective'> Scheduling and tracking</topic>
      <topic importance='elective'> Project management tools</topic>
      <topic importance='elective'> Cost/benefit analysis</topic>
      <topic importance='elective'> Software measurement and estimation techniques
      </topic>
      <topic importance='elective'> Software quality assurance and the role of measurements
      </topic>
      <topic importance='elective'> Risk</topic>
      <topic importance='elective'> Risk identification and management</topic>
      <topic importance='elective'> Risk analysis and evaluation</topic>
      <topic importance='elective'>Risk tolerance (e.g.,  risk-adverse,   risk-neutral,   risk-seeking)</topic>
      <topic importance='elective'>isk planning
      </topic>
      <topic importance='elective'> System-wide  approach to risk including hazards associated with tools
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss common behaviors that contribute to the effective functioning of a team. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Create and follow an agenda for a team meeting. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify and justify necessary roles in a software development team. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Understand the sources, hazards, and potential benefits of team conflict. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply a conflict resolution strategy in a team setting. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use an  ad hoc  method to estimate software development effort (e.g., time) and compare to actual effort required. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>List several examples of software risks. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the impact of risk in a software development lifecycle. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe different categories of risk in software systems. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate through involvement in a team project the central elements of team building and team management. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe how the choice of process model affects team organizational structures and  decision-making  processes. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create a team by identifying appropriate roles and assigning roles to team members. </outcome>
      <outcome importance='elective' mastery_level='usage'>Assess and provide feedback to teams and individuals on their performance in a team setting. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Using a particular software process, describe the aspects of a project that need to be planned and monitored, (e.g., estimates of size and effort, a schedule, resource allocation, configuration control, change management, and project risk identification and management). </outcome>
      <outcome importance='elective' mastery_level='usage'>Track the progress of some stage in a project using appropriate project metrics. </outcome>
      <outcome importance='elective' mastery_level='usage'>Compare simple software size and cost estimation techniques. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use a project management tool to assist in the assignment and tracking of tasks in a software development project. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Describe the impact of risk tolerance on the software development process. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify risks and describe approaches to managing risk (avoidance, acceptance, transference, mitigation), and characterize the strengths and shortcomings of each. </outcome>
      <outcome importance='elective' mastery_level='usage'>Explain how risk affects decisions in the software development process. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify security risks for a software system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate a systematic approach to the task of identifying hazards and risks in a particular situation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply the basic principles of risk management in a variety of simple scenarios including a security situation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Conduct a cost/benefit analysis for a risk mitigation approach. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify and analyze some of the risks for an entire system that arise from aspects other than the software. </outcome>
    </knowledgeArea>
    <knowledgeArea id='TAE' name='Tools and Environments'>
      <topic importance='tier2'> Software configuration management and version control
      </topic>
      <topic importance='tier2'> Release management
      </topic>
      <topic importance='tier2'> Requirements analysis and design modeling tools
      </topic>
      <topic importance='tier2'> Testing tools including static and dynamic analysis tools
      </topic>
      <topic importance='tier2'>Programming environments that automate parts of program construction processes (e.g., automated builds)
      </topic>
      <topic importance='tier2'>ontinuous integration
      </topic>
      <topic importance='tier2'> Tool integration concepts and mechanisms
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the difference between centralized and distributed software configuration management. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how version control can be used to help manage software release management. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify configuration items and use a source code control tool in a small  team-based  project. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how available static and dynamic test tools can be integrated into the software development environment. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the issues that are important in selecting a set of tools for the development of a particular software system, including tools for requirements tracking, design modeling, implementation, build automation, and testing. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Demonstrate the capability to use software tools in support of the development of a software product of medium size. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RE' name='Requirements Engineering'>
      <topic importance='tier1'> Describing functional requirements using, for example, use cases or users stories
      </topic>
      <topic importance='tier1'> Properties of requirements including consistency, validity, completeness, and feasibility
      </topic>
      <topic importance='tier2'> Software requirements elicitation
      </topic>
      <topic importance='tier2'> Describing system data using, for example, class diagrams or  entity-relationship  diagrams
      </topic>
      <topic importance='tier2'> Non-functional  requirements and their relationship to software quality  (cross-reference  IAS/Secure Software Engineering)
      </topic>
      <topic importance='tier2'> Evaluation and use of requirements specifications
      </topic>
      <topic importance='elective'> Requirements analysis modeling techniques
      </topic>
      <topic importance='elective'> Acceptability of certainty / uncertainty considerations regarding software / system behavior
      </topic>
      <topic importance='elective'> Prototyping
      </topic>
      <topic importance='elective'> Basic concepts of formal requirements specification
      </topic>
      <topic importance='elective'> Requirements specification
      </topic>
      <topic importance='elective'> Requirements validation
      </topic>
      <topic importance='elective'> Requirements tracing
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>List the key components of a use case or similar description of some behavior that is required for a system. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how the requirements engineering process supports the elicitation and validation of behavioral requirements. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Interpret a given requirements model for a simple software system. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the fundamental challenges of and common techniques used for requirements elicitation. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>List the key components of a data model (e.g., class diagrams or ER diagrams). </outcome>
      <outcome importance='tier2' mastery_level='usage'>Identify both functional and  non-functional  requirements in a given requirements specification for a software system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Conduct a review of a set of software requirements to determine the quality of the requirements with respect to the characteristics of good requirements. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply key elements and common methods for elicitation and analysis to produce a set of software requirements for a  medium-sized  software system. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Compare the  plan-driven  and agile approaches to requirements specification and validation and describe the benefits and risks associated with each. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use a common,  non-formal  method to model and specify the requirements for a  medium-size  software system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Translate into natural language a software requirements specification (e.g., a software component contract) written in a formal specification language. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create a prototype of a software system to mitigate risk in requirements. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Differentiate between forward and backward tracing and explain their roles in the requirements validation process. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SD' name='Software Design'>
      <topic importance='tier1'> System design principles: levels of abstraction (architectural design and detailed design), separation of concerns, information hiding, coupling and cohesion,  re-use  of standard structures
      </topic>
      <topic importance='tier1'> Design Paradigms such as structured design  (top-down  functional decomposition),  object-oriented  analysis and design, event driven design,  component-level  design,  data-structured  centered, aspect oriented, function oriented, service oriented
      </topic>
      <topic importance='tier1'> Structural and behavioral models of software designs
      </topic>
      <topic importance='tier1'> Design patterns
      </topic>
      <topic importance='tier2'> Relationships between requirements and designs: transformation of models, design of contracts, invariants
      </topic>
      <topic importance='tier2'> Software architecture concepts and standard architectures (e.g.  client-server,   n-layer,  transform centered,  pipes-and-filters)
      </topic>
      <topic importance='tier2'> Refactoring designs using design patterns
      </topic>
      <topic importance='tier2'> The use of components in design: component selection, design, adaptation and assembly of components, components and patterns, components and objects (for example, building a GUI using a standard widget set)
      </topic>
      <topic importance='elective'> Internal design qualities, and models for them: efficiency and performance, redundancy and fault tolerance, traceability of requirements
      </topic>
      <topic importance='elective'> External design qualities, and models for them: functionality, reliability, performance and efficiency, usability, maintainability, portability
      </topic>
      <topic importance='elective'> Measurement and analysis of design quality
      </topic>
      <topic importance='elective'> Tradeoffs between different aspects of quality
      </topic>
      <topic importance='elective'> Application frameworks
      </topic>
      <topic importance='elective'> Middleware: the  object-oriented  paradigm within middleware, object request brokers and marshalling, transaction processing monitors, workflow systems
      </topic>
      <topic importance='elective'> Principles of secure design and coding  (cross-reference  IAS/Principles of Secure Design)</topic>
      <topic importance='elective'>Principle of least privilege</topic>
      <topic importance='elective'>rinciple of  fail-safe  defaults</topic>
      <topic importance='elective'>  Principle of psychological acceptability</topic>
      <outcome importance='tier1' mastery_level='familiarity'>Articulate design principles including separation of concerns, information hiding, coupling and cohesion, and encapsulation. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use a design paradigm to design a simple software system, and explain how system design principles have been applied in this design. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Construct models of the design of a simple software system that are appropriate for the paradigm used to design it. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Within the context of a single design paradigm, describe one or more design patterns that could be applicable to the design of a simple software system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>For a simple system suitable for a given scenario, discuss and select an appropriate design paradigm. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Create appropriate models for the structure and behavior of software products from their requirements specifications. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Explain the relationships between the requirements for a software product and its design, using appropriate models. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>For the design of a simple software system within the context of a single design paradigm, describe the software architecture of that system. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Given a  high-level  design, identify the software architecture by differentiating among common software architectures such as    pipe-and-filter,  and  client-server.  </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Investigate the impact of software architectures selection on the design of a simple system. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply simple examples of patterns in a software design. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe a form of refactoring and discuss when it may be applicable. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Select suitable components for use in the design of a software product. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain how suitable components might need to be adapted for use in the design of a software product. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Design a contract for a typical small software component for use in a given system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Discuss and select appropriate software architecture for a simple system suitable for a given scenario. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply models for internal and external qualities in designing software components to achieve an acceptable tradeoff between conflicting quality aspects. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze a software design from the perspective of a significant internal quality attribute. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Analyze a software design from the perspective of a significant external quality attribute. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the role of objects in middleware systems and the relationship with components. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply  component-oriented  approaches to the design of a range of software, such as using components for concurrency and transactions, for reliable communication services, for database interaction including services for remote query and database management, or for secure communication and access. </outcome>
      <outcome importance='elective' mastery_level='usage'>Refactor an existing software implementation to improve some aspect of its design. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>State and apply the principles of least privilege and  fail-safe  defaults. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SC' name='Software Construction'>
      <topic importance='tier2'> Coding practices: techniques, idioms/patterns, mechanisms for building quality programs  (cross-reference  IAS/Defensive Programming; SDF/Development Methods)</topic>
      <topic importance='tier2'>Defensive coding practices</topic>
      <topic importance='tier2'>ecure coding practices</topic>
      <topic importance='tier2'>  Using exception handling mechanisms to make programs more robust,  fault-tolerant</topic>
      <topic importance='tier2'> Coding standards
      </topic>
      <topic importance='tier2'> Integration strategies
      </topic>
      <topic importance='tier2'> Development context: “green field” vs. existing code base</topic>
      <topic importance='tier2'>Change impact analysis</topic>
      <topic importance='tier2'>hange actualization
      </topic>
      <topic importance='elective'> Potential security problems in programs</topic>
      <topic importance='elective'>Buffer and other types of overflows</topic>
      <topic importance='elective'>ace conditions</topic>
      <topic importance='elective'>Improper initialization, including choice of privileges</topic>
      <topic importance='elective'>hecking input</topic>
      <topic importance='elective'>Assuming success and correctness</topic>
      <topic importance='elective'>alidating assumptions
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Describe techniques, coding idioms and mechanisms for implementing designs to achieve desired properties such as reliability, efficiency, and robustness. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Build robust code using exception handling mechanisms. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe secure coding and defensive coding practices. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Select and use a defined coding standard in a small software project. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Compare and contrast integration strategies including  top-down,   bottom-up,  and sandwich integration. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the process of analyzing and implementing changes to code base developed for a specific project. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the process of analyzing and implementing changes to a large existing code base. </outcome>
      <outcome importance='elective' mastery_level='usage'>Rewrite a simple program to remove common vulnerabilities, such as buffer overflows, integer overflows and race conditions. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write a software component that performs some  non-trivial  task and is resilient to input and  run-time  errors. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SVAV' name='Software Verification and Validation'>
      <topic importance='tier2'> Verification and validation concepts
      </topic>
      <topic importance='tier2'> Inspections, reviews, audits
      </topic>
      <topic importance='tier2'> Testing types, including human computer interface, usability, reliability, security, conformance to specification  (cross-reference  IAS/Secure Software Engineering)
      </topic>
      <topic importance='tier2'> Testing fundamentals  (cross-reference  SDF/Development Methods)</topic>
      <topic importance='tier2'>Unit, integration, validation, and system testing</topic>
      <topic importance='tier2'>est plan creation and test case generation</topic>
      <topic importance='tier2'>Black-box  and  white-box  testing techniques</topic>
      <topic importance='tier2'>egression testing and test automation
      </topic>
      <topic importance='tier2'> Defect tracking
      </topic>
      <topic importance='tier2'> Limitations of testing in particular domains, such as parallel or  safety-critical  systems
      </topic>
      <topic importance='elective'> Static approaches and dynamic approaches to verification
      </topic>
      <topic importance='elective'> Test-driven  development
      </topic>
      <topic importance='elective'> Validation planning; documentation for validation
      </topic>
      <topic importance='elective'> Object-oriented  testing; systems testing
      </topic>
      <topic importance='elective'> Verification and validation of  non-code  artifacts (documentation, help files, training materials)
      </topic>
      <topic importance='elective'> Fault logging, fault tracking and technical support for such activities
      </topic>
      <topic importance='elective'> Fault estimation and testing termination including defect seeding
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Distinguish between program validation and verification. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the role that tools can play in the validation of software. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Undertake, as part of a team activity, an inspection of a  medium-size  code segment. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe and distinguish among the different types and levels of testing (unit, integration, systems, and acceptance). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe techniques for identifying significant test cases for integration, regression and system testing. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Create and document a set of tests for a  medium-size  code segment. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how to select good regression tests and automate them. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use a defect tracking tool to manage software defects in a small software project. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the limitations of testing in a particular domain. </outcome>
      <outcome importance='elective' mastery_level='usage'>Evaluate a test suite for a  medium-size  code segment. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Compare static and dynamic approaches to verification. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the fundamental principles of  test-driven  development methods and explain the role of automated testing in these methods. </outcome>
      <outcome importance='elective' mastery_level='usage'>Discuss the issues involving the testing of  object-oriented  software. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe techniques for the verification and validation of  non-code  artifacts. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe approaches for fault estimation. </outcome>
      <outcome importance='elective' mastery_level='usage'>Estimate the number of faults in a small software application based on fault density and fault seeding. </outcome>
      <outcome importance='elective' mastery_level='usage'>Conduct an inspection or review of software source code for a small or medium sized software project. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SE' name='Software Evolution'>
      <topic importance='tier2'>Software development in the context of large,  pre-existing  code bases
      </topic>
      <topic importance='tier2'>software change</topic>
      <topic importance='tier2'>Concerns and concern location</topic>
      <topic importance='tier2'>efactoring
      </topic>
      <topic importance='tier2'> Software evolution
      </topic>
      <topic importance='tier2'> Characteristics of maintainable software
      </topic>
      <topic importance='tier2'> Reengineering systems
      </topic>
      <topic importance='tier2'> Software reuse</topic>
      <topic importance='tier2'> Code segments</topic>
      <topic importance='tier2'>Libraries and frameworks</topic>
      <topic importance='tier2'>omponents</topic>
      <topic importance='tier2'>  Product lines</topic>
      <outcome importance='tier2' mastery_level='familiarity'>Identify the principal issues associated with software evolution and explain their impact on the software lifecycle. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Estimate the impact of a change request to an existing product of medium size. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Use refactoring in the process of modifying a software component. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the challenges of evolving systems in a changing environment. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Outline the process of regression testing and its role in release management. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss the advantages and disadvantages of different types of software reuse. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SR' name='Software Reliability'>
      <topic importance='tier2'> Software reliability engineering concepts
      </topic>
      <topic importance='tier2'> Software reliability, system reliability and failure behavior  (cross-reference  SF/Reliability Through Redundancy)
      </topic>
      <topic importance='tier2'> Fault lifecycle concepts and techniques
      </topic>
      <topic importance='elective'> Software reliability models
      </topic>
      <topic importance='elective'> Software fault tolerance techniques and models
      </topic>
      <topic importance='elective'> Software reliability engineering practices
      </topic>
      <topic importance='elective'> Measurement-based  analysis of software reliability
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the problems that exist in achieving very high levels of reliability. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how software reliability contributes to system reliability. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>List approaches to minimizing faults that can be applied at each stage of the software lifecycle. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Compare the characteristics of three different reliability modeling approaches. </outcome>
      <outcome importance='elective' mastery_level='usage'>Demonstrate the ability to apply multiple methods to develop reliability estimates for a software system. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify methods that will lead to the realization of a software architecture that achieves a specified level of reliability. </outcome>
      <outcome importance='elective' mastery_level='usage'>Identify ways to apply redundancy to achieve fault tolerance for a  medium-sized  application. </outcome>
    </knowledgeArea>
    <knowledgeArea id='FM' name='Formal Methods'>
      <topic importance='elective'> Role of formal specification and analysis techniques in the software development cycle
      </topic>
      <topic importance='elective'> Program assertion languages and analysis approaches (including languages for writing and analyzing pre- and  post-conditions,  such as OCL, JML)
      </topic>
      <topic importance='elective'> Formal approaches to software modeling and analysis</topic>
      <topic importance='elective'>Model checkers</topic>
      <topic importance='elective'>odel finders
      </topic>
      <topic importance='elective'> Tools in support of formal methods
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Describe the role formal specification and analysis techniques can play in the development of complex software and compare their use as validation and verification techniques with testing. </outcome>
      <outcome importance='elective' mastery_level='usage'>Apply formal specification and analysis techniques to software designs and programs with low complexity. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the potential benefits and drawbacks of using formal specification languages. </outcome>
      <outcome importance='elective' mastery_level='usage'>Create and evaluate program assertions for a variety of behaviors ranging from simple through complex. </outcome>
      <outcome importance='elective' mastery_level='usage'>Using a common formal specification language, formulate the specification of a simple software system and derive examples of test cases from the specification. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='SF' name='Systems Fundamentals'>
    <knowledgeArea id='CP' name='Computational Paradigms'>
      <topic importance='tier1'> Basic building blocks and components of a computer (gates,  flip-flops,  registers, interconnections; Datapath + Control + Memory)
      </topic>
      <topic importance='tier1'> Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions, minimization, sum of product forms
      </topic>
      <topic importance='tier1'> Application-level  sequential processing: single thread
      </topic>
      <topic importance='tier1'> Simple  application-level  parallel processing: request level (web  services/client-server/distributed),  single thread per server, multiple threads with multiple servers
      </topic>
      <topic importance='tier1'> Basic concept of pipelining, overlapped processing stages
      </topic>
      <topic importance='tier1'> Basic concept of scaling: going faster vs. handling larger problems
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>List commonly encountered patterns of how computations are organized. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the basic building blocks of computers and their role in the historical development of computer architecture. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Articulate the differences between single thread vs. multiple thread, single server vs. multiple server models, motivated by real world examples (e.g., cooking recipes, lines for multiple teller machines and couples shopping for food). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Articulate the concept of strong vs. weak scaling, i.e., how performance is affected by scale of problem vs. scale of resources to solve the problem. This can be motivated by the simple,  real-world  examples. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Design a simple logic circuit using the fundamental building blocks of logic design. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Use tools for capture, synthesis, and simulation to evaluate a logic design. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write a simple sequential problem and a simple parallel version of the same program. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate performance of simple sequential and parallel versions of a program with different problem sizes, and be able to describe the  speed-ups  achieved. </outcome>
    </knowledgeArea>
    <knowledgeArea id='CC' name='Cross-Layer  Communications'>
      <topic importance='tier1'> Programming abstractions, interfaces, use of libraries
      </topic>
      <topic importance='tier1'> Distinction between Application and OS services, Remote Procedure Call
      </topic>
      <topic importance='tier1'> Application-Virtual  Machine Interaction
      </topic>
      <topic importance='tier1'> Reliability
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how computing systems are constructed of layers upon layers, based on separation of concerns, with  well-defined  interfaces, hiding details of low layers from the higher layers. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe how hardware, VM, OS, and applications are additional layers of interpretation/processing. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the mechanisms of how errors are detected, signaled back, and handled through the layers. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Construct a simple program using methods of layering, error detection and recovery, and reflection of error status across layers. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Find bugs in a layered program by using tools for program tracing, single stepping, and debugging. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SASM' name='State and State Machines'>
      <topic importance='tier1'> Digital vs. Analog/Discrete vs. Continuous Systems
      </topic>
      <topic importance='tier1'> Simple logic gates, logical expressions, Boolean logic simplification
      </topic>
      <topic importance='tier1'> Clocks, State, Sequencing
      </topic>
      <topic importance='tier1'> Combinational Logic, Sequential Logic, Registers, Memories
      </topic>
      <topic importance='tier1'> Computers and Network Protocols as examples of state machines
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe computations as a system characyterized by a known set of configurations with transitions from one unique configuration (state) to another (state). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the distinction between systems whose output is only a function of their input (Combinational) and those with memory/history (Sequential). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe a computer as a state machine that interprets machine instructions. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain how a program or network protocol can also be expressed as a state machine, and that alternative representations for the same computation can exist. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Develop state machine descriptions for simple problem statement solutions (e.g., traffic light sequencing, pattern recognizers). </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Derive  time-series  behavior of a state machine from its state machine representation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='P' name='Parallelism'>
      <topic importance='tier1'> Sequential vs. parallel processing
      </topic>
      <topic importance='tier1'> Parallel programming vs. concurrent programming
      </topic>
      <topic importance='tier1'> Request parallelism vs. Task parallelism
      </topic>
      <topic importance='tier1'> Client-Server/Web  Services, Thread  (Fork-Join),  Pipelining
      </topic>
      <topic importance='tier1'> Multicore architectures and hardware support for synchronization
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>For a given program, distinguish between its sequential and parallel execution, and the performance implications thereof. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Demonstrate on an execution time line that parallelism events and operations can take place simultaneously (i.e., at the same time). Explain how work can be performed in less elapsed time if this can be exploited. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain other uses of parallelism, such as for reliability/redundancy of execution. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Define the differences between the concepts of Instruction Parallelism, Data Parallelism, Thread Parallelism/Multitasking, Task/Request Parallelism. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Write more than one parallel program (e.g., one simple parallel program in more than one parallel programming paradigm; a simple parallel program that manages shared resources through synchronization primitives; a simple parallel program that performs simultaneous operation on partitioned data through task parallel (e.g., parallel search terms; a simple parallel program that performs  step-by-step  pipeline processing through message passing). </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Use performance tools to measure  speed-up  achieved by parallel programs in terms of both problem size and number of resources. </outcome>
    </knowledgeArea>
    <knowledgeArea id='E' name='Evaluation'>
      <topic importance='tier1'> Performance figures of merit
      </topic>
      <topic importance='tier1'> Workloads and representative benchmarks, and methods of collecting and analyzing performance figures of merit
      </topic>
      <topic importance='tier1'> CPI (Cycles per Instruction) equation as tool for understanding tradeoffs in the design of instruction sets, processor pipelines, and memory system organizations.
      </topic>
      <topic importance='tier1'> Amdahl’s Law: the part of the computation that cannot be sped up limits the effect of the parts that can
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Explain how the components of system architecture contribute to improving its performance. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe Amdahl’s law and discuss its limitations. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Design and conduct a  performance-oriented  experiment. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Use software tools to profile and measure program performance. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RAAS' name='Resource Allocation and Scheduling'>
      <topic importance='tier2'> Kinds of resources (e.g., processor share, memory, disk, net bandwidth)
      </topic>
      <topic importance='tier2'> Kinds of scheduling (e.g.,  first-come,  priority)
      </topic>
      <topic importance='tier2'> Advantages of fair scheduling, preemptive scheduling
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Define how finite computer resources (e.g., processor share, memory, storage and network bandwidth) are managed by their careful allocation to existing entities. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the scheduling algorithms by which resources are allocated to competing entities, and the figures of merit by which these algorithms are evaluated, such as fairness. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Implement simple schedule algorithms. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Use figures of merit of alternative scheduler implementations. </outcome>
    </knowledgeArea>
    <knowledgeArea id='P2' name='Proximity'>
      <topic importance='tier2'> Speed of light and computers (one foot per nanosecond vs. one GHz clocks)
      </topic>
      <topic importance='tier2'> Latencies in computer systems: memory vs. disk latencies vs. across the network memory
      </topic>
      <topic importance='tier2'> Caches and the effects of spatial and temporal locality on performance in processors and systems
      </topic>
      <topic importance='tier2'> Caches and cache coherency in databases, operating systems, distributed systems, and computer architecture
      </topic>
      <topic importance='tier2'> Introduction into the processor memory hierarchy and the formula for average memory access time
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the importance of locality in determining performance. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe why things that are close in space take less time to access. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Calculate average memory access time and describe the tradeoffs in memory hierarchy performance in terms of capacity, miss/hit rate, and access time. </outcome>
    </knowledgeArea>
    <knowledgeArea id='VAI' name='Virtualization and Isolation'>
      <topic importance='tier2'> Rationale for protection and predictable performance
      </topic>
      <topic importance='tier2'> Levels of indirection, illustrated by virtual memory for managing physical memory resources
      </topic>
      <topic importance='tier2'> Methods for implementing virtual memory and virtual machines
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain why it is important to isolate and protect the execution of individual programs and environments that share common underlying resources. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe how the concept of indirection can create the illusion of a dedicated machine and its resources even when physically shared among multiple programs and environments. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Measure the performance of two application instances running on separate virtual machines, and determine the effect of performance isolation. </outcome>
    </knowledgeArea>
    <knowledgeArea id='RTR' name='Reliability through Redundancy'>
      <topic importance='tier2'> Distinction between bugs and faults
      </topic>
      <topic importance='tier2'> Redundancy through check and retry
      </topic>
      <topic importance='tier2'> Redundancy through redundant encoding (error correcting codes, CRC, FEC)
      </topic>
      <topic importance='tier2'> Duplication/mirroring/replicas
      </topic>
      <topic importance='tier2'> Other approaches to fault tolerance and availability
      </topic>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the distinction between program errors, system errors, and hardware faults (e.g., bad memory) and exceptions (e.g., attempt to divide by zero). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Articulate the distinction between detecting, handling, and recovering from faults, and the methods for their implementation. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the role of error correcting codes in providing error checking and correction techniques in memories, storage, and networks. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Apply simple algorithms for exploiting redundant information for the purposes of data correction. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Compare different error detection and correction methods for their data overhead, implementation complexity, and relative execution time for encoding, detecting, and correcting errors. </outcome>
    </knowledgeArea>
    <knowledgeArea id='QE' name='Quantitative Evaluation'>
      <topic importance='elective'> Analytical tools to guide quantitative evaluation
      </topic>
      <topic importance='elective'> Order of magnitude analysis  (Big-Oh  notation)
      </topic>
      <topic importance='elective'> Analysis of slow and fast paths of a system
      </topic>
      <topic importance='elective'> Events on their effect on performance (e.g., instruction stalls, cache misses, page faults)
      </topic>
      <topic importance='elective'> Understanding layered systems, workloads, and platforms, their implications for performance, and the challenges they represent for evaluation
      </topic>
      <topic importance='elective'> Microbenchmarking pitfalls
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Explain the circumstances in which a given figure of system performance metric is useful. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Explain the inadequacies of benchmarks as a measure of system performance. </outcome>
      <outcome importance='elective' mastery_level='usage'>Use limit studies or simple calculations to produce  order-of-magnitude  estimates for a given performance metric in a given context. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Conduct a performance experiment on a layered system to determine the effect of a system parameter on figure of system performance. </outcome>
    </knowledgeArea>
  </knowledgeArea>
  <knowledgeArea id='SP' name='Social Issues and Professional Practice'>
    <knowledgeArea id='SC' name='Social Context'>
      <topic importance='tier1'> Social implications of computing in a networked world  (cross-reference  HCI/Foundations/social models; IAS/Fundamental Concepts/social issues)
      </topic>
      <topic importance='tier1'> Impact of social media on individualism, collectivism and culture.
      </topic>
      <topic importance='tier2'> Growth and control of the Internet  (cross-reference  NC/Introduction/organization of the Internet)
      </topic>
      <topic importance='tier2'> Often referred to as the digital divide, differences in access to digital technology resources and its resulting ramifications for gender, class, ethnicity, geography, and/or underdeveloped countries.
      </topic>
      <topic importance='tier2'> Accessibility issues, including legal requirements
      </topic>
      <topic importance='tier2'> Context-aware  computing  (cross-reference  HCI/Design for  non-mouse  interfaces/ ubiquitous and context- aware)
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Describe positive and negative ways in which computer technology (networks, mobile computing, cloud computing) alters modes of social interaction at the personal level. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify developers’ assumptions and values embedded in hardware and software design, especially as they pertain to usability for diverse populations including  under-represented  populations and the disabled. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Interpret the social context of a given design and its implementation. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate the efficacy of a given design and implementation using empirical data. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Summarize the implications of social media on individualism versus collectivism and culture. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Discuss how Internet access serves as a liberating force for people living under oppressive forms of government; explain how limits on Internet access are used as tools of political and social repression. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Analyze the pros and cons of reliance on computing in the implementation of democracy (e.g. delivery of social services, electronic voting). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the impact of the  under-representation  of diverse populations in the computing profession (e.g., industry culture, product diversity). </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the implications of context awareness in ubiquitous computing systems. </outcome>
    </knowledgeArea>
    <knowledgeArea id='AT' name='Analytical Tools'>
      <topic importance='tier1'> Ethical argumentation
      </topic>
      <topic importance='tier1'> Ethical theories and  decision-making
      </topic>
      <topic importance='tier1'> Moral assumptions and values
      </topic>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate stakeholder positions in a given situation. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Analyze basic logical fallacies in an argument. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Analyze an argument to identify premises and conclusion. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Illustrate the use of example and analogy in ethical argument. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate ethical/social tradeoffs in technical decisions. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PE' name='Professional Ethics'>
      <topic importance='tier1'> Community values and the laws by which we live
      </topic>
      <topic importance='tier1'> The nature of professionalism including care, attention and discipline, fiduciary responsibility, and mentoring
      </topic>
      <topic importance='tier1'> Keeping  up-to-date  as a computing professional in terms of familiarity, tools, skills, legal and professional framework as well as the ability to  self-assess  and progress in the computing field
      </topic>
      <topic importance='tier1'> Professional certification, codes of ethics, conduct, and practice, such as the  ACM/IEEE-CS,  SE, AITP, IFIP and international societies  (cross-reference  IAS/Fundamental Concepts/ethical issues)
      </topic>
      <topic importance='tier1'> Accountability, responsibility and liability (e.g. software correctness, reliability and safety, as well as ethical confidentiality of cybersecurity professionals)
      </topic>
      <topic importance='tier2'> The role of the computing professional in public policy
      </topic>
      <topic importance='tier2'> Maintaining awareness of consequences
      </topic>
      <topic importance='tier2'> Ethical dissent and  whistle-blowing
      </topic>
      <topic importance='tier2'> The relationship between regional culture and ethical dilemmas
      </topic>
      <topic importance='tier2'> Dealing with harassment and discrimination
      </topic>
      <topic importance='tier2'> Forms of professional credentialing
      </topic>
      <topic importance='tier2'> Acceptable use policies for computing in the workplace
      </topic>
      <topic importance='tier2'> Ergonomics and healthy computing environments
      </topic>
      <topic importance='tier2'> Time to market and cost considerations versus quality professional standards
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Identify ethical issues that arise in software development and determine how to address them technically and ethically. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Explain the ethical responsibility of ensuring software correctness, reliability and safety. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the mechanisms that typically exist for a professional to keep  up-to-date.  </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the strengths and weaknesses of relevant professional codes as expressions of professionalism and guides to  decision-making.  </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Analyze a global computing issue, observing the role of professionals and government officials in managing this problem. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate the professional codes of ethics from the ACM, the IEEE Computer Society, and other organizations. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe ways in which professionals may contribute to public policy. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the consequences of inappropriate professional behavior. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify progressive stages in a  whistle-blowing  incident. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Identify examples of how regional culture interplays with ethical dilemmas. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Investigate forms of harassment and discrimination and avenues of assistance. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Examine various forms of professional credentialing. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Explain the relationship between ergonomics in computing environments and people’s health. </outcome>
      <outcome importance='tier2' mastery_level='assessment'>Develop a computer usage/acceptable use policy with enforcement measures. </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe issues associated with industries’ push to focus on time to market versus enforcing quality professional standards. </outcome>
    </knowledgeArea>
    <knowledgeArea id='IP' name='Intellectual Property'>
      <topic importance='tier1'> Philosophical foundations of intellectual property
      </topic>
      <topic importance='tier1'> Intellectual property rights  (cross-reference  IM/Information Storage and Retrieval/intellectual property and protection)
      </topic>
      <topic importance='tier1'> Intangible digital intellectual property (IDIP)
      </topic>
      <topic importance='tier1'> Legal foundations for intellectual property protection
      </topic>
      <topic importance='tier1'> Digital rights management
      </topic>
      <topic importance='tier1'> Copyrights, patents, trade secrets, trademarks
      </topic>
      <topic importance='tier1'> Plagiarism
      </topic>
      <topic importance='elective'> Foundations of the open source movement
      </topic>
      <topic importance='elective'> Software piracy
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the philosophical bases of intellectual property. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the rationale for the legal protection of intellectual property. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe legislation aimed at digital copyright infringements. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Critique legislation aimed at digital copyright infringements. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Identify contemporary examples of intangible digital intellectual property. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Justify uses of copyrighted materials. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate the ethical issues inherent in various plagiarism detection mechanisms. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Interpret the intent and implementation of software licensing. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the issues involved in securing software patents. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Characterize and contrast the concepts of copyright, patenting and trademarks. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the goals of the open source movement. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the global nature of software piracy. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PACL' name='Privacy and Civil Liberties'>
      <topic importance='tier1'> Philosophical foundations of privacy rights  (cross-reference  IS/Fundamental Issues/philosophical issues)
      </topic>
      <topic importance='tier1'> Legal foundations of privacy protection
      </topic>
      <topic importance='tier1'> Privacy implications of widespread data collection for transactional databases, data warehouses, surveillance systems, and cloud computing  (cross-reference  IM/Database Systems/data independence; IM/Data Mining/data cleaning)
      </topic>
      <topic importance='tier1'> Ramifications of differential privacy
      </topic>
      <topic importance='tier1'> Technology-based  solutions for privacy protection  (cross-reference  IAS/Threats and Attacks/attacks on privacy and anonymity)
      </topic>
      <topic importance='elective'> Privacy legislation in areas of practice
      </topic>
      <topic importance='elective'> Civil liberties and cultural differences
      </topic>
      <topic importance='elective'> Freedom of expression and its limitations
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Discuss the philosophical basis for the legal protection of personal privacy. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate solutions to privacy threats in transactional databases and data warehouses. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the role of data collection in the implementation of pervasive surveillance systems (e.g., RFID, face recognition, toll collection, mobile computing). </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the ramifications of differential privacy. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Investigate the impact of technological solutions to privacy problems. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Critique the intent, potential value and implementation of various forms of privacy legislation. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify strategies to enable appropriate freedom of expression. </outcome>
    </knowledgeArea>
    <knowledgeArea id='PC' name='Professional Communication'>
      <topic importance='tier1'> Reading, understanding and summarizing technical material, including source code and documentation
      </topic>
      <topic importance='tier1'> Writing effective technical documentation and materials
      </topic>
      <topic importance='tier1'> Dynamics of oral, written, and electronic team and group communication  (cross-reference  HCI/Collaboration and Communication/group communication; SE/Project Management/team participation)
      </topic>
      <topic importance='tier1'> Communicating professionally with stakeholders
      </topic>
      <topic importance='tier1'> Utilizing collaboration tools  (cross-reference  HCI/Collaboration and Communication/online communities; IS/Agents/collaborative agents)
      </topic>
      <topic importance='elective'> Dealing with  cross-cultural  environments  (cross-reference   HCI/User-Centered  Design and Testing/cross- cultural evaluation)
      </topic>
      <topic importance='elective'> Tradeoffs of competing risks in software projects, such as technology, structure/process, quality, people, market and financial  (cross-reference  SE/Software Project Management/Risk)
      </topic>
      <outcome importance='tier1' mastery_level='usage'>Write clear, concise, and accurate technical documents following  well-defined  standards for format and for including appropriate tables, figures, and references. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Evaluate written technical documentation to detect problems of various kinds. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Develop and deliver a good quality formal presentation. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Plan interactions (e.g. virtual,  face-to-face,  shared documents) with others in which they are able to get their point across, and are also able to listen carefully and appreciate the points of others, even when they disagree, and are able to convey to others what they have heard. </outcome>
      <outcome importance='tier1' mastery_level='familiarity'>Describe the strengths and weaknesses of various forms of communication (e.g. virtual,  face-to-face,  shared documents). </outcome>
      <outcome importance='tier1' mastery_level='usage'>Examine appropriate measures used to communicate with stakeholders involved in a project. </outcome>
      <outcome importance='tier1' mastery_level='assessment'>Compare and contrast various collaboration tools. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss ways to influence performance and results in  cross-cultural  teams. </outcome>
      <outcome importance='elective' mastery_level='usage'>Examine the tradeoffs and common sources of risk in software projects regarding technology, structure/process, quality, people, market and financial. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Evaluate personal strengths and weaknesses to work remotely as part of a multinational team. </outcome>
    </knowledgeArea>
    <knowledgeArea id='S' name='Sustainability'>
      <topic importance='tier1'> Being a sustainable practitioner by taking into consideration cultural and environmental impacts of implementation decisions (e.g. organizational policies, economic viability, and resource consumption).
      </topic>
      <topic importance='tier1'> Explore global social and environmental impacts of computer use and disposal  (e-waste)
      </topic>
      <topic importance='tier2'> Environmental impacts of design choices in specific areas such as algorithms, operating systems, networks, databases, or  human-computer  interaction  (cross-reference  SE/Software Evaluation/software evolution;  HCI/Design-Oriented  HCI/sustainability)
      </topic>
      <topic importance='elective'> Guidelines for sustainable design standards
      </topic>
      <topic importance='elective'> Systemic effects of complex  computer-mediated  phenomena (e.g. telecommuting or web shopping)
      </topic>
      <topic importance='elective'> Pervasive computing; information processing integrated into everyday objects and activities, such as smart energy systems, social networking and feedback systems to promote sustainable behavior, transportation, environmental monitoring, citizen science and activism.
      </topic>
      <topic importance='elective'> Research on applications of computing to environmental issues, such as energy, pollution, resource usage, recycling and reuse, food management, farming and others.
      </topic>
      <topic importance='elective'> The interdependence of the sustainability of software systems with social systems, including the knowledge and skills of its users, organizational processes and policies, and its societal context (e.g., market forces, government policies).
      </topic>
      <outcome importance='tier1' mastery_level='familiarity'>Identify ways to be a sustainable practitioner. </outcome>
      <outcome importance='tier1' mastery_level='usage'>Illustrate global social and environmental impacts of computer use and disposal  (e-waste).  </outcome>
      <outcome importance='tier2' mastery_level='familiarity'>Describe the environmental impacts of design choices within the field of computing that relate to algorithm design, operating system design, networking design, database design, etc. </outcome>
      <outcome importance='tier2' mastery_level='usage'>Investigate the social and environmental impacts of new system designs through projects. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify guidelines for sustainable IT design or deployment. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>List the sustainable effects of telecommuting or web shopping. </outcome>
      <outcome importance='elective' mastery_level='usage'>Investigate pervasive computing in areas such as smart energy systems, social networking, transportation, agriculture,  supply-chain  systems, environmental monitoring and citizen activism. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Develop applications of computing and assess through research areas pertaining to environmental issues (e.g. energy, pollution, resource usage, recycling and reuse, food management, farming). </outcome>
    </knowledgeArea>
    <knowledgeArea id='H' name='History'>
      <topic importance='elective'> Prehistory—the  world before 1946
      </topic>
      <topic importance='elective'> History of computer hardware, software, networking  (cross-reference  AR/Digital logic and digital systems/ history of computer architecture)
      </topic>
      <topic importance='elective'> Pioneers of computing
      </topic>
      <topic importance='elective'> History of the Internet
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Identify significant continuing trends in the history of the computing field. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the contributions of several pioneers in the computing field. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the historical context for several programming language paradigms. </outcome>
      <outcome importance='elective' mastery_level='assessment'>Compare daily life before and after the advent of personal computers and the Internet. </outcome>
    </knowledgeArea>
    <knowledgeArea id='EOC' name='Economies of Computing'>
      <topic importance='elective'> Monopolies and their economic implications
      </topic>
      <topic importance='elective'> Effect of skilled labor supply and demand on the quality of computing products
      </topic>
      <topic importance='elective'> Pricing strategies in the computing domain
      </topic>
      <topic importance='elective'> The phenomenon of outsourcing and  off-shoring  software development; impacts on employment and on economics
      </topic>
      <topic importance='elective'> Consequences of globalization for the computer science profession
      </topic>
      <topic importance='elective'> Differences in access to computing resources and the possible effects thereof
      </topic>
      <topic importance='elective'> Cost/benefit analysis of jobs with considerations to manufacturing, hardware, software, and engineering implications
      </topic>
      <topic importance='elective'> Cost estimates versus actual costs in relation to total costs
      </topic>
      <topic importance='elective'> Entrepreneurship: prospects and pitfalls
      </topic>
      <topic importance='elective'> Network effect or  demand-side  economies of scale
      </topic>
      <topic importance='elective'> Use of engineering economics in dealing with finances
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>Summarize the rationale for antimonopoly efforts. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify several ways in which the information technology industry is affected by shortages in the labor supply. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify the evolution of pricing strategies for computing goods and services. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the benefits, the drawbacks and the implications of  off-shoring  and outsourcing. </outcome>
      <outcome importance='elective' mastery_level='usage'>Investigate and defend ways to address limitations on access to computing. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the economic benefits of network effects. </outcome>
    </knowledgeArea>
    <knowledgeArea id='SPLACC' name='Security Policies, Laws and Computer Crimes'>
      <topic importance='elective'> Examples of computer crimes and legal redress for computer criminals  (cross-reference  IAS/Digital Forensics/rules of evidence)
      </topic>
      <topic importance='elective'> Social engineering, identity theft and recovery  (cross-reference  HCI/Human Factors and Security/trust, privacy and deception)
      </topic>
      <topic importance='elective'> Issues surrounding the misuse of access and breaches in security
      </topic>
      <topic importance='elective'> Motivations and ramifications of cyber terrorism and criminal hacking, “cracking”
      </topic>
      <topic importance='elective'> Effects of malware, such as viruses, worms and Trojan horses
      </topic>
      <topic importance='elective'> Crime prevention strategies
      </topic>
      <topic importance='elective'> Security policies  (cross-reference  IAS/Security Policy and Governance/policies)
      </topic>
      <outcome importance='elective' mastery_level='familiarity'>List classic examples of computer crimes and social engineering incidents with societal impact. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Identify laws that apply to computer crimes. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Describe the motivation and ramifications of cyber terrorism and criminal hacking. </outcome>
      <outcome importance='elective' mastery_level='usage'>Examine the ethical and legal issues surrounding the misuse of access and various breaches in security. </outcome>
      <outcome importance='elective' mastery_level='familiarity'>Discuss the professional's role in security and the  trade-offs  involved. </outcome>
      <outcome importance='elective' mastery_level='usage'>Investigate measures that can be taken by both individuals and organizations including governments to prevent or mitigate the undesirable effects of computer crimes and identity theft. </outcome>
      <outcome importance='elective' mastery_level='usage'>Write a  company-wide  security policy, which includes procedures for managing passwords and employee monitoring. </outcome>
  </knowledgeArea>
</knowledgeArea>
</curriculumStandard>
